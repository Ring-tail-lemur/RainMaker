/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { AmqpError } from 'rhea-promise';
import { AzureLogger } from '@azure/logger';
import { Connection } from 'rhea-promise';
import { Message } from 'rhea-promise';
import { MessageHeader } from 'rhea-promise';
import { MessageProperties } from 'rhea-promise';
import { NamedKeyCredential } from '@azure/core-auth';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { ReqResLink } from 'rhea-promise';
import { SASCredential } from '@azure/core-auth';
import { Sender } from 'rhea-promise';
import { SenderOptions } from 'rhea-promise';
import { Session } from 'rhea-promise';
import { WebSocketImpl } from 'rhea-promise';

/**
 * Describes the properties that must be provided while acquiring a lock.
 */
export declare interface AcquireLockProperties {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel lock acquisition.
     * This only applies to the acquisition of a lock. Once the lock is acquired, the task is invoked and `acquire`
     * can no longer be cancelled.
     * This does not cancel running the task passed to `acquire()` if the lock has been acquired,
     * but will prevent it from running if cancelled before the task is invoked.
     */
    abortSignal: AbortSignalLike | undefined;
    /**
     * The allowed amount of time in milliseconds to acquire a lock.
     * If a lock isn't acquired within this time, the promise returned
     * by `acquire()` will be rejected with an Error.
     */
    timeoutInMs: number | undefined;
}

/**
 * Describes the AmqpAnnotatedMessage, part of the ServiceBusReceivedMessage(as `amqpAnnotatedMessage` property).
 */
export declare interface AmqpAnnotatedMessage {
    /**
     * Describes the defined set of standard header properties of the message.
     */
    header?: AmqpMessageHeader;
    /**
     * Describes set of footer properties of the message.
     */
    footer?: {
        [key: string]: any;
    };
    /**
     * A dictionary containing message attributes that will be held in the message header
     */
    messageAnnotations?: {
        [key: string]: any;
    };
    /**
     * A dictionary used for delivery-specific
     * non-standard properties at the head of the message.
     */
    deliveryAnnotations?: {
        [key: string]: any;
    };
    /**
     * A dictionary containing application specific message properties.
     */
    applicationProperties?: {
        [key: string]: any;
    };
    /**
     *  Describes the defined set of standard properties of the message.
     */
    properties?: AmqpMessageProperties;
    /**
     * The message body.
     */
    body: any;
    /**
     * The AMQP section where the data was decoded from.
     */
    bodyType?: "data" | "sequence" | "value";
}

/**
 * Describes the operations that can be performed on(or to get) the AmqpAnnotatedMessage.
 */
export declare const AmqpAnnotatedMessage: {
    /**
     * Takes RheaMessage(`Message` type from "rhea") and returns it in the AmqpAnnotatedMessage format.
     */
    fromRheaMessage(msg: Message): AmqpAnnotatedMessage;
    /**
     * Takes AmqpAnnotatedMessage and returns it in the RheaMessage(`Message` type from "rhea") format.
     */
    toRheaMessage(msg: AmqpAnnotatedMessage): Message;
};

/**
 * Describes the defined set of standard header properties of the message.
 */
export declare interface AmqpMessageHeader {
    /**
     * If this value is true, then this message has not been
     * acquired by any other link. If this value is false, then this message MAY have previously
     * been acquired by another link or links.
     */
    firstAcquirer?: boolean;
    /**
     * The number of prior unsuccessful delivery attempts.
     */
    deliveryCount?: number;
    /**
     * time to live in ms.
     */
    timeToLive?: number;
    /**
     * Specifies durability requirements.
     */
    durable?: boolean;
    /**
     * The relative message priority. Higher numbers indicate higher
     * priority messages.
     */
    priority?: number;
}

/**
 * Describes the operations that can be performed on the message header.
 */
export declare const AmqpMessageHeader: {
    /**
     * Converts MessageHeader to RheaMessageHeader.
     *
     * @param props - Message header.
     * @returns RheaMessageHeader
     */
    toRheaMessageHeader(props: AmqpMessageHeader): MessageHeader;
    /**
     * Converts RheaMessageHeader to MessageHeader.
     *
     * @param props - Amqp Message Header
     * @returns MessageHeader.
     */
    fromRheaMessageHeader(props: MessageHeader): AmqpMessageHeader;
};

/**
 * Describes the defined set of standard properties of the message.
 */
export declare interface AmqpMessageProperties {
    /**
     * The application message identifier that uniquely identifies a message.
     * The user is responsible for making sure that this is unique in the given context. Guids usually make a good fit.
     */
    messageId?: string | number | Buffer;
    /**
     * The address of the node to send replies to.
     */
    replyTo?: string;
    /**
     * The address of the node the message is destined for.
     */
    to?: string;
    /**
     * The id that can be used to mark or identify messages between clients.
     */
    correlationId?: string | number | Buffer;
    /**
     * MIME type for the message.
     */
    contentType?: string;
    /**
     * The content-encoding property is used as a modifier to the content-type.
     * When present, its value indicates what additional content encodings have been applied to the application-data.
     */
    contentEncoding?: string;
    /**
     * The time when this message is considered expired.
     */
    absoluteExpiryTime?: number;
    /**
     * The time this message was created.
     */
    creationTime?: number;
    /**
     * The group this message belongs to.
     */
    groupId?: string;
    /**
     * The sequence number of this message with its group.
     */
    groupSequence?: number;
    /**
     * The group the reply message belongs to.
     */
    replyToGroupId?: string;
    /**
     * A common field for summary information about the message
     * content and purpose.
     */
    subject?: string;
}

/**
 * Describes the operations that can be performed on the amqp message properties.
 */
export declare const AmqpMessageProperties: {
    /**
     * Converts MessageProperties to RheaMessageProperties.
     * @param props - Message properties.
     * @returns RheaMessageProperties.
     */
    toRheaMessageProperties(props: AmqpMessageProperties): MessageProperties;
    /**
     * Converts RheaMessageProperties to MessageProperties.
     * @param props - Amqp message properties.
     * @returns MessageProperties.
     */
    fromRheaMessageProperties(props: MessageProperties): AmqpMessageProperties;
};

/**
 * CancellableAsyncLock provides a mechanism for forcing tasks using the same
 * 'key' to be executed serially.
 *
 * Pending tasks can be manually cancelled via an abortSignal or automatically
 * cancelled by reach a provided timeout value.
 */
export declare interface CancellableAsyncLock {
    /**
     * Returns a promise that resolves to the value returned by the provided task function.
     * Only 1 task can be invoked at a time for a given `key` value.
     *
     * An acquire call can be cancelled via an `abortSignal`.
     * If cancelled, the promise will be rejected with an `AbortError`.
     *
     * `acquireTimeoutInMs` can also be provided to properties.
     * If the timeout is reached before the provided `task` is invoked,
     * then the promise will be rejected with an Error stating the task
     * timed out waiting to acquire a lock.
     *
     * @param key - All `acquire` calls are grouped by the provided `key`.
     * @param task - The function to invoke once the lock has been acquired.
     * @param properties - Additional properties to control the behavior of `acquire`.
     */
    acquire<T = void>(key: string, task: (...args: any[]) => Promise<T>, properties: AcquireLockProperties): Promise<T>;
}

/**
 * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endpoint over AMQP connection.
 */
export declare class CbsClient {
    /**
     * CBS endpoint - "$cbs"
     */
    readonly endpoint: string;
    /**
     * CBS replyTo - The receiver link name that the service should reply to.
     */
    readonly replyTo: string;
    /**
     * The unique lock name per $cbs session per connection that is used to
     * acquire the lock for establishing a cbs session if one does not exist for an amqp connection.
     */
    readonly cbsLock: string;
    /**
     * The unique lock name per connection that is used to
     * acquire the lock for establishing an amqp connection if one does not exist.
     */
    readonly connectionLock: string;
    /**
     * The AMQP connection.
     */
    connection: Connection;
    /**
     * CBS sender, receiver on the same session.
     */
    private _cbsSenderReceiverLink?;
    /**
     * @param connection - The AMQP connection.
     * @param connectionLock - A unique string (usually a guid) per connection.
     */
    constructor(connection: Connection, connectionLock: string);
    /**
     * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
     * the given connection.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `init` invocation.
     * @returns Promise<void>.
     */
    init(options?: {
        abortSignal?: AbortSignalLike;
        timeoutInMs?: number;
    }): Promise<void>;
    /**
     * Negotiates the CBS claim with the EventHub/ServiceBus Service.
     * @param audience - The entity token audience for which the token is requested in one
     * of the following forms:
     *
     * - **ServiceBus**
     *    - **Sender**
     *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **Receiver**
     *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
     *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
     *
     * - **EventHubs**
     *     - **Sender**
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     *     - **Receiver**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     *     - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     * @param token - The token that needs to be sent in the put-token request.
     * @param tokenType - The type of token being used. For example, 'jwt' or 'servicebus.windows.net:sastoken'.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `negotiateClaim` invocation.
     * @returns A Promise that resolves when $cbs authentication is successful
     * and rejects when an error occurs during $cbs authentication.
     */
    negotiateClaim(audience: string, token: string, tokenType: TokenType, options?: {
        abortSignal?: AbortSignalLike;
        timeoutInMs?: number;
    }): Promise<CbsResponse>;
    /**
     * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns
     */
    close(): Promise<void>;
    /**
     * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * @returns void
     */
    remove(): void;
    /**
     * Indicates whether the cbs sender receiver link is open or closed.
     * @returns `true` open, `false` closed.
     */
    isOpen(): boolean;
    private _fromRheaMessageResponse;
}

/**
 * Describes the CBS Response.
 */
export declare interface CbsResponse {
    correlationId: string;
    statusCode: string;
    statusDescription: string;
}

/**
 * Maps the amqp error conditions to the Error names.
 */
export declare enum ConditionErrorNameMapper {
    /**
     * Error is thrown when the address is already in use.
     */
    "com.microsoft:address-already-in-use" = "AddressAlreadyInUseError",
    /**
     * Error is thrown when the store lock is lost.
     */
    "com.microsoft:store-lock-lost" = "StoreLockLostError",
    /**
     * Error is thrown when a matching subscription is not found.
     */
    "com.microsoft:no-matching-subscription" = "NoMatchingSubscriptionError",
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */
    "com.microsoft:partition-not-owned" = "PartitionNotOwnedError",
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    "com.microsoft:publisher-revoked" = "PublisherRevokedError",
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    "com.microsoft:entity-already-exists" = "MessagingEntityAlreadyExistsError",
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    "com.microsoft:entity-disabled" = "MessagingEntityDisabledError",
    /**
     * Error is thrown when the lock on the message is lost.
     */
    "com.microsoft:message-lock-lost" = "MessageLockLostError",
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    "com.microsoft:session-lock-lost" = "SessionLockLostError",
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    "com.microsoft:session-cannot-be-locked" = "SessionCannotBeLockedError",
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */
    "amqp:internal-error" = "InternalServerError",
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    "amqp:not-found" = "ServiceCommunicationError",
    /**
     * Error is thrown when the message is not found.
     */
    "com.microsoft:message-not-found" = "MessageNotFoundError",
    /**
     * Error is thrown when relay is not found.
     */
    "com.microsoft:relay-not-found" = "RelayNotFoundError",
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    "amqp:not-implemented" = "NotImplementedError",
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    "amqp:not-allowed" = "InvalidOperationError",
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    "amqp:resource-limit-exceeded" = "QuotaExceededError",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    "amqp:unauthorized-access" = "UnauthorizedError",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    "com.microsoft:auth-failed" = "UnauthorizedError",
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    "com.microsoft:timeout" = "ServiceUnavailableError",
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    "com.microsoft:message-wait-timeout" = "MessageWaitTimeout",
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    "com.microsoft:argument-out-of-range" = "ArgumentOutOfRangeError",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    "amqp:precondition-failed" = "PreconditionFailedError",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    "com.microsoft:precondition-failed" = "PreconditionFailedError",
    /**
     * Error is thrown when data could not be decoded.
     */
    "amqp:decode-error" = "DecodeError",
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    "amqp:invalid-field" = "InvalidFieldError",
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    "amqp:resource-locked" = "ResourceLockedError",
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    "amqp:resource-deleted" = "ResourceDeletedError",
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    "amqp:illegal-state" = "IllegalStateError",
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    "amqp:frame-size-too-small" = "FrameSizeTooSmallError",
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    "amqp:link:detach-forced" = "DetachForcedError",
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    "amqp:link:transfer-limit-exceeded" = "TransferLimitExceededError",
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    "amqp:link:message-size-exceeded" = "MessageTooLargeError",
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    "amqp:link:redirect" = "LinkRedirectError",
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    "amqp:link:stolen" = "ReceiverDisconnectedError",
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    "amqp:session:window-violation" = "SessionWindowViolationError",
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    "amqp:session:errant-link" = "ErrantLinkError",
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    "amqp:session:handle-in-use" = "HandleInUseError",
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    "amqp:session:unattached-handle" = "UnattachedHandleError",
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    "amqp:connection:forced" = "ConnectionForcedError",
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    "amqp:connection:framing-error" = "FramingError",
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    "amqp:connection:redirect" = "ConnectionRedirectError",
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    "com.microsoft:server-busy" = "ServerBusyError",
    /**
     * Error is thrown when an incorrect argument was received.
     */
    "com.microsoft:argument-error" = "ArgumentError",
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    "com.microsoft:operation-cancelled" = "OperationCancelledError",
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    "client.sender:not-enough-link-credit" = "SenderBusyError",
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
     */
    "system:error" = "SystemError"
}

/**
 * Describes the connection config object that is created after parsing an EventHub or ServiceBus
 * connection string.
 */
export declare interface ConnectionConfig {
    /**
     * The service bus endpoint
     * "sb://<yournamespace>.servicebus.windows.net/".
     */
    endpoint: string;
    /**
     * The DNS hostname or IP address of the service.
     * Typically of the form "<yournamespace>.servicebus.windows.net" unless connecting
     * to the service through an intermediary.
     */
    host: string;
    /**
     * The fully qualified name of the host to connect to.
     * This field can be used by AMQP proxies to determine the correct back-end service to
     * connect the client to.
     * Typically of the form "<yournamespace>.servicebus.windows.net".
     */
    amqpHostname?: string;
    /**
     * The port number.
     */
    port?: number;
    /**
     * The connection string.
     */
    connectionString: string;
    /**
     * The name/path of the entity (hub/queue/topic name) to which the
     * connection needs to happen.
     */
    entityPath?: string;
    /**
     * The name of the access key.
     */
    sharedAccessKeyName: string;
    /**
     * The secret value of the access key.
     */
    sharedAccessKey: string;
    /**
     * The WebSocket constructor used to create an AMQP connection
     * over a WebSocket. In browsers, the built-in WebSocket will be  used by default. In Node, a
     * TCP socket will be used if a WebSocket constructor is not provided.
     */
    webSocket?: WebSocketImpl;
    /**
     * The path for the endpoint that accepts an AMQP
     * connection over WebSockets.
     */
    webSocketEndpointPath?: string;
    /**
     * Options to be passed to the WebSocket constructor
     */
    webSocketConstructorOptions?: any;
}

/**
 * Describes the ConnectionConfig module
 */
export declare const ConnectionConfig: {
    /**
     * Creates the connection config.
     * @param connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param path - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns ConnectionConfig
     */
    create(connectionString: string, path?: string | undefined): ConnectionConfig;
    /**
     * Validates the properties of connection config.
     * @param config - The connection config to be validated.
     * @returns void
     */
    validate(config: ConnectionConfig, options?: ConnectionConfigOptions | undefined): void;
};

/**
 * Describes the options that can be provided while creating a connection config.
 */
export declare interface ConnectionConfigOptions {
    /**
     * Indicates whether the entity path is required in the
     * connection config.
     */
    isEntityPathRequired?: boolean;
}

/**
 * Provides contextual information like the underlying amqp connection, cbs session, tokenProvider,
 * Connection config, data transformer, etc.
 */
export declare interface ConnectionContextBase {
    /**
     * The EventHub connection config that is created after
     * parsing the connection string.
     */
    readonly config: ConnectionConfig;
    /**
     * The unique lock name per connection that is used to
     * acquire the lock for establishing an amqp connection per client if one does not exist.
     */
    connectionLock: string;
    /**
     * The unique lock name per connection that is used to
     * acquire the lock for negotiating cbs claim by an entity on that connection.
     */
    negotiateClaimLock: string;
    /**
     * The underlying AMQP connection.
     */
    connection: Connection;
    /**
     * The amqp connection id that uniquely identifies the
     * connection within a process.
     */
    connectionId: string;
    /**
     * Indicates whether the close() method was
     * called on the connection object.
     */
    wasConnectionCloseCalled: boolean;
    /**
     * A reference to the cbs session ($cbs endpoint) on the
     * underlying AMQP connection for the EventHub Client.
     */
    cbsSession: CbsClient;
    /**
     * Updates the context to use a new underlying AMQP connection and new cbs session.
     */
    refreshConnection: () => void;
}

export declare const ConnectionContextBase: {
    /**
     * Creates the base connection context.
     * @param parameters - Parameters to be provided to create
     * the base connection context.
     */
    create(parameters: CreateConnectionContextBaseParameters): ConnectionContextBase;
};

/**
 * Defines the properties that need to be set while establishing the AMQP connection.
 */
export declare interface ConnectionProperties {
    /**
     * The name of the product that will be populated as the AMQP
     * connection property. Example: "MSJSClient".
     */
    product: string;
    /**
     * The version of the package/sdk that is making the AMQP connection.
     */
    version: string;
    /**
     * The userAgent that needs to be set as the AMQP connection
     * property. Example: `"/js-service-bus"` or `"/js-event-hubs,/js-event-processor-host=1.0.0"`.
     */
    userAgent: string;
}

export declare const Constants: {
    readonly associatedLinkName: "associated-link-name";
    readonly partitionKey: "x-opt-partition-key";
    readonly sequenceNumber: "x-opt-sequence-number";
    readonly enqueueSequenceNumber: "x-opt-enqueue-sequence-number";
    readonly enqueuedTime: "x-opt-enqueued-time";
    readonly scheduledEnqueueTime: "x-opt-scheduled-enqueue-time";
    readonly offset: "x-opt-offset";
    readonly lockedUntil: "x-opt-locked-until";
    readonly partitionIdName: "x-opt-partition-id";
    readonly publisher: "x-opt-publisher-name";
    readonly viaPartitionKey: "x-opt-via-partition-key";
    readonly deadLetterSource: "x-opt-deadletter-source";
    readonly messageState: "x-opt-message-state";
    readonly enqueuedTimeAnnotation: "amqp.annotation.x-opt-enqueued-time";
    readonly offsetAnnotation: "amqp.annotation.x-opt-offset";
    readonly sequenceNumberAnnotation: "amqp.annotation.x-opt-sequence-number";
    readonly guidSize: 16;
    readonly message: "message";
    readonly error: "error";
    readonly statusCode: "status-code";
    readonly statusDescription: "status-description";
    readonly errorCondition: "error-condition";
    readonly management: "$management";
    readonly partition: "partition";
    readonly partitionId: "partitionId";
    readonly readOperation: "READ";
    readonly TLS: "tls";
    readonly establishConnection: "establishConnection";
    readonly defaultConsumerGroup: "$default";
    readonly eventHub: "eventhub";
    readonly cbsEndpoint: "$cbs";
    readonly cbsReplyTo: "cbs";
    readonly operationPutToken: "put-token";
    readonly aadEventHubsAudience: "https://eventhubs.azure.net/";
    readonly aadEventHubsScope: "https://eventhubs.azure.net//.default";
    readonly aadServiceBusAudience: "https://servicebus.azure.net/";
    readonly aadServiceBusScope: "https://servicebus.azure.net//.default";
    readonly maxUserAgentLength: 512;
    readonly vendorString: "com.microsoft";
    readonly attachEpoch: "com.microsoft:epoch";
    readonly receiverIdentifierName: "com.microsoft:receiver-name";
    readonly enableReceiverRuntimeMetricName: "com.microsoft:enable-receiver-runtime-metric";
    readonly timespan: "com.microsoft:timespan";
    readonly uri: "com.microsoft:uri";
    readonly dateTimeOffset: "com.microsoft:datetime-offset";
    readonly sessionFilterName: "com.microsoft:session-filter";
    readonly receiverError: "receiver_error";
    readonly senderError: "sender_error";
    readonly sessionError: "session_error";
    readonly connectionError: "connection_error";
    readonly defaultOperationTimeoutInMs: 60000;
    readonly defaultConnectionIdleTimeoutInMs: 60000;
    readonly managementRequestKey: "managementRequest";
    readonly negotiateCbsKey: "negotiateCbs";
    readonly negotiateClaim: "negotiateClaim";
    readonly ensureContainerAndBlob: "ensureContainerAndBlob";
    readonly defaultPrefetchCount: 1000;
    readonly reconnectLimit: 100;
    readonly maxMessageIdLength: 128;
    readonly maxPartitionKeyLength: 128;
    readonly maxSessionIdLength: 128;
    readonly pathDelimiter: "/";
    readonly ruleNameMaximumLength: 50;
    readonly maximumSqlFilterStatementLength: 1024;
    readonly maximumSqlRuleActionStatementLength: 1024;
    readonly maxDeadLetterReasonLength: 4096;
    readonly maxDurationValue: 922337203685477;
    readonly minDurationValue: -922337203685477;
    readonly maxAbsoluteExpiryTime: number;
    readonly aadTokenValidityMarginInMs: 5000;
    readonly connectionReconnectDelay: 300;
    readonly defaultMaxRetries: 3;
    readonly defaultMaxRetriesForConnection: 150;
    readonly defaultDelayBetweenOperationRetriesInMs: 30000;
    readonly defaultMaxDelayForExponentialRetryInMs: 90000;
    readonly receiverSettleMode: "receiver-settle-mode";
    readonly dispositionStatus: "disposition-status";
    readonly fromSequenceNumber: "from-sequence-number";
    readonly messageCount: "message-count";
    readonly lockTokens: "lock-tokens";
    readonly messageIdMapKey: "message-id";
    readonly sequenceNumberMapKey: "sequence-number";
    readonly lockTokenMapKey: "lock-token";
    readonly sessionIdMapKey: "session-id";
    readonly sequenceNumbers: "sequence-numbers";
    readonly deadLetterReason: "deadletter-reason";
    readonly deadLetterDescription: "deadletter-description";
    readonly propertiesToModify: "properties-to-modify";
    readonly deadLetterName: "com.microsoft:dead-letter";
    readonly trackingId: "com.microsoft:tracking-id";
    readonly serverTimeout: "com.microsoft:server-timeout";
    readonly operations: {
        readonly putToken: "put-token";
        readonly read: "READ";
        readonly cancelScheduledMessage: "com.microsoft:cancel-scheduled-message";
        readonly scheduleMessage: "com.microsoft:schedule-message";
        readonly renewLock: "com.microsoft:renew-lock";
        readonly peekMessage: "com.microsoft:peek-message";
        readonly receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number";
        readonly updateDisposition: "com.microsoft:update-disposition";
        readonly renewSessionLock: "com.microsoft:renew-session-lock";
        readonly setSessionState: "com.microsoft:set-session-state";
        readonly getSessionState: "com.microsoft:get-session-state";
        readonly enumerateSessions: "com.microsoft:get-message-sessions";
        readonly addRule: "com.microsoft:add-rule";
        readonly removeRule: "com.microsoft:remove-rule";
        readonly enumerateRules: "com.microsoft:enumerate-rules";
    };
    readonly descriptorCodes: {
        readonly ruleDescriptionList: 1335734829060;
        readonly sqlFilterList: 83483426822;
        readonly correlationFilterList: 83483426825;
        readonly sqlRuleActionList: 1335734829062;
        readonly trueFilterList: 83483426823;
        readonly falseFilterList: 83483426824;
    };
};

/**
 * Describes the parameters that can be provided to create the base connection context.
 */
export declare interface CreateConnectionContextBaseParameters {
    /**
     * The connection config that is created by parsing the
     * connection string.
     */
    config: ConnectionConfig;
    /**
     * Properties to be provided while creating
     * the AMQP connection.
     */
    connectionProperties: ConnectionProperties;
    /**
     * Determines whether entity path should be a part of
     * the connection config. If `true` it must be present, `false` otherwise. Default value false.
     */
    isEntityPathRequired?: boolean;
    /**
     * The duration in which the promise should
     * complete (resolve/reject). If it is not completed, then the Promise will be rejected after
     * timeout occurs. Default: `60000 milliseconds`.
     */
    operationTimeoutInMs?: number;
}

/**
 * Creates a token provider from the provided shared access data.
 * @param data - The sharedAccessKeyName/sharedAccessKey pair or the sharedAccessSignature.
 * @hidden
 */
export declare function createSasTokenProvider(data: {
    sharedAccessKeyName: string;
    sharedAccessKey: string;
} | {
    sharedAccessSignature: string;
} | NamedKeyCredential | SASCredential): SasTokenProvider;

/**
 * The cancellable async lock instance.
 */
export declare const defaultCancellableLock: CancellableAsyncLock;

/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param delayInMs - The number of milliseconds to be delayed.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns - Resolved promise
 */
export declare function delay<T>(delayInMs: number, abortSignal?: AbortSignalLike, abortErrorMsg?: string, value?: T): Promise<T | void>;

/**
 * Maps the Error names to the amqp error conditions.
 */
export declare enum ErrorNameConditionMapper {
    /**
     * Error is thrown when the address is already in use.
     */
    AddressAlreadyInUseError = "com.microsoft:address-already-in-use",
    /**
     * Error is thrown when the store lock is lost.
     */
    StoreLockLostError = "com.microsoft:store-lock-lost",
    /**
     * Error is thrown when a matching subscription is not found.
     */
    NoMatchingSubscriptionError = "com.microsoft:no-matching-subscription",
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */
    PartitionNotOwnedError = "com.microsoft:partition-not-owned",
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    PublisherRevokedError = "com.microsoft:publisher-revoked",
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    MessagingEntityAlreadyExistsError = "com.microsoft:entity-already-exists",
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    MessagingEntityDisabledError = "com.microsoft:entity-disabled",
    /**
     * Error is thrown when the lock on the message is lost.
     */
    MessageLockLostError = "com.microsoft:message-lock-lost",
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    SessionLockLostError = "com.microsoft:session-lock-lost",
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    SessionCannotBeLockedError = "com.microsoft:session-cannot-be-locked",
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */
    InternalServerError = "amqp:internal-error",
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ServiceCommunicationError = "amqp:not-found",
    /**
     * Error is thrown when message is not found.
     */
    MessageNotFoundError = "com.microsoft:message-not-found",
    /**
     * Error is thrown when relay is not found.
     */
    RelayNotFoundError = "com.microsoft:relay-not-found",
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    NotImplementedError = "amqp:not-implemented",
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    InvalidOperationError = "amqp:not-allowed",
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    QuotaExceededError = "amqp:resource-limit-exceeded",
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    UnauthorizedError = "amqp:unauthorized-access",
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ServiceUnavailableError = "com.microsoft:timeout",
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    MessageWaitTimeout = "com.microsoft:message-wait-timeout",
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ArgumentOutOfRangeError = "com.microsoft:argument-out-of-range",
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    PreconditionFailedError = "amqp:precondition-failed",
    /**
     * Error is thrown when data could not be decoded.
     */
    DecodeError = "amqp:decode-error",
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    InvalidFieldError = "amqp:invalid-field",
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ResourceLockedError = "amqp:resource-locked",
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ResourceDeletedError = "amqp:resource-deleted",
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    IllegalStateError = "amqp:illegal-state",
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    FrameSizeTooSmallError = "amqp:frame-size-too-small",
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    DetachForcedError = "amqp:link:detach-forced",
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    TransferLimitExceededError = "amqp:link:transfer-limit-exceeded",
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    MessageTooLargeError = "amqp:link:message-size-exceeded",
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    LinkRedirectError = "amqp:link:redirect",
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ReceiverDisconnectedError = "amqp:link:stolen",
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    SessionWindowViolationError = "amqp:session:window-violation",
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ErrantLinkError = "amqp:session:errant-link",
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    HandleInUseError = "amqp:session:handle-in-use",
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    UnattachedHandleError = "amqp:session:unattached-handle",
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ConnectionForcedError = "amqp:connection:forced",
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    FramingError = "amqp:connection:framing-error",
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ConnectionRedirectError = "amqp:connection:redirect",
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ServerBusyError = "com.microsoft:server-busy",
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ArgumentError = "com.microsoft:argument-error",
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    OperationCancelledError = "com.microsoft:operation-cancelled",
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    SenderBusyError = "client.sender:not-enough-link-credit",
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
     */
    SystemError = "system:error"
}

/**
 * Determines if an error is a MessagingError.
 *
 * @param error - An error that can either be an Error or a MessagingError.
 */
export declare function isMessagingError(error: Error | MessagingError): error is MessagingError;

/**
 * Typeguard that checks if the input is a SasTokenProvider.
 * @param thing - Any object.
 * @hidden
 */
export declare function isSasTokenProvider(thing: unknown): thing is SasTokenProvider;

/**
 * Checks whether the provided error is a node.js SystemError.
 * @param err - An object that may contain error information.
 */
export declare function isSystemError(err: unknown): err is NetworkSystemError;

/**
 * The \@azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
export declare const logger: AzureLogger;

/**
 * Describes the base class for Messaging Error.
 */
export declare class MessagingError extends Error {
    /**
     * Address to which the network connection failed.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    address?: string;
    /**
     * A string label that identifies the error.
     */
    code?: string;
    /**
     * System-provided error number.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    errno?: number | string;
    /**
     * The error name. Default value: "MessagingError".
     */
    name: string;
    /**
     * The unavailable network connection port.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    port?: number;
    /**
     * Name of the system call that triggered the error.
     * Only present if the `MessagingError` was instantiated with a Node.js `SystemError`.
     */
    syscall?: string;
    /**
     *
     * Describes whether the error is retryable. Default: true.
     */
    retryable: boolean;
    /**
     * Extra details about the error.
     */
    info?: any;
    /**
     * @param message - The error message that provides more information about the error.
     * @param originalError - An error whose properties will be copied to the MessagingError if the
     * property matches one found on the Node.js `SystemError`.
     */
    constructor(message: string, originalError?: Error);
}

/**
 * Describes the fields on a Node.js SystemError.
 * Omits fields that are not related to network calls (e.g. file system calls).
 * See https://nodejs.org/dist/latest-v12.x/docs/api/errors.html#errors_class_systemerror
 */
export declare interface NetworkSystemError {
    address?: string;
    code: string;
    errno: string | number;
    info?: any;
    message: string;
    name: string;
    port?: number;
    stack: string;
    syscall: string;
}

/**
 * Parses the connection string and returns an object of type T.
 *
 * Connection strings have the following syntax:
 *
 * ConnectionString ::= `Part { ";" Part } [ ";" ] [ WhiteSpace ]`
 * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
 * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
 * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
 * WhiteSpace       ::= ? all whitespace characters including `\r` and `\n` ?
 *
 * @param connectionString - The connection string to be parsed.
 * @returns ParsedOutput<T>.
 */
export declare function parseConnectionString<T>(connectionString: string): ParsedOutput<T>;

/**
 * Defines an object with possible properties defined in T.
 */
export declare type ParsedOutput<T> = {
    [P in keyof T]: T[P];
};

/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 */
export declare class RequestResponseLink implements ReqResLink {
    session: Session;
    sender: Sender;
    receiver: Receiver;
    /**
     * @param session - The amqp session.
     * @param sender - The amqp sender link.
     * @param receiver - The amqp receiver link.
     */
    constructor(session: Session, sender: Sender, receiver: Receiver);
    /**
     * Maintains a map of responses that
     * are being actively returned. It acts as a store for correlating the responses received for
     * the send requests.
     */
    private _responsesMap;
    /**
     * Provides the underlying amqp connection object.
     * @returns Connection.
     */
    get connection(): Connection;
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen(): boolean;
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param request - The AMQP (request) message.
     * @param options - Options that can be provided while sending a request.
     * @returns Promise<Message> The AMQP (response) message.
     */
    sendRequest(request: Message, options?: SendRequestOptions): Promise<Message>;
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns Promise<void>
     */
    close(): Promise<void>;
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns void
     */
    remove(): void;
    /**
     * Creates an amqp request/response link.
     *
     * @param connection - The amqp connection.
     * @param senderOptions - Options that must be provided to create the sender link.
     * @param receiverOptions - Options that must be provided to create the receiver link.
     * @param createOptions - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `create` invocation.
     * @returns Promise<RequestResponseLink>
     */
    static create(connection: Connection, senderOptions: SenderOptions, receiverOptions: ReceiverOptions, createOptions?: {
        abortSignal?: AbortSignalLike;
    }): Promise<RequestResponseLink>;
}

/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param config - Parameters to configure retry operation
 *
 * @returns Promise<T>.
 */
export declare function retry<T>(config: RetryConfig<T>): Promise<T>;

/**
 * Provides a list of retryable AMQP errors.
 * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
 * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
 * "TransferLimitExceededError"
 */
export declare const retryableErrors: string[];

/**
 * Describes the parameters that need to be configured for the retry operation.
 */
export declare interface RetryConfig<T> {
    /**
     * The operation that needs to be retried.
     */
    operation: () => Promise<T>;
    /**
     * The connection identifier. Used in logging information.
     * Extremely useful when multiple connections are logged in the same file.
     */
    connectionId: string;
    /**
     * The name/type of operation to be performed.
     * Extremely useful in providing better debug logs.
     */
    operationType: RetryOperationType;
    /**
     * The host "<yournamespace>.servicebus.windows.net".
     * Used to check network connectivity.
     */
    connectionHost?: string;
    /**
     * The retry related options associated with given operation execution.
     */
    retryOptions?: RetryOptions;
    /**
     * The `AbortSignal` associated with the operation being retried on.
     * If this signal is fired during the wait time between retries, then the `retry()` method will ensure that the wait is abandoned and the retry process gets cancelled. If this signal is fired when the operation is in progress, then the operation is expected to react to it.
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Describes the Retry Mode type
 */
export declare enum RetryMode {
    Exponential = 0,
    Fixed = 1
}

/**
 * Describes the retry operation type.
 */
export declare enum RetryOperationType {
    cbsAuth = "cbsAuth",
    connection = "connection",
    management = "management",
    receiverLink = "receiverLink",
    senderLink = "senderLink",
    sendMessage = "sendMessage",
    receiveMessage = "receiveMessage",
    session = "session",
    messageSettlement = "settlement"
}

/**
 * Retry policy options that determine the mode, number of retries, retry interval etc.
 */
export declare interface RetryOptions {
    /**
     * Number of times the operation needs to be retried in case
     * of retryable error. Default: 3.
     */
    maxRetries?: number;
    /**
     * Amount of time to wait in milliseconds before making the
     * next attempt. Default: `30000 milliseconds`.
     * When `mode` option is set to `Exponential`,
     * this is used to compute the exponentially increasing delays between retries.
     */
    retryDelayInMs?: number;
    /**
     * Number of milliseconds to wait before declaring that current attempt has timed out which will trigger a retry
     * A minimum value of `60000` milliseconds will be used if a value not greater than this is provided.
     */
    timeoutInMs?: number;
    /**
     * Denotes which retry mode to apply. If undefined, defaults to `Fixed`
     */
    mode?: RetryMode;
    /**
     * Denotes the maximum delay between retries
     * that the retry attempts will be capped at. Applicable only when performing exponential retry.
     */
    maxRetryDelayInMs?: number;
}

/**
 * A SasTokenProvider provides an alternative to TokenCredential for providing an `AccessToken`.
 * @hidden
 */
export declare interface SasTokenProvider {
    /**
     * Property used to distinguish SasTokenProvider from TokenCredential.
     */
    isSasTokenProvider: true;
    /**
     * Gets the token provided by this provider.
     *
     * This method is called automatically by Azure SDK client libraries.
     *
     * @param audience - The audience for which the token is desired.
     */
    getToken(audience: string): AccessToken;
}

/**
 * Describes the options that can be specified while sending a request.
 */
export declare interface SendRequestOptions {
    /**
     * Cancels the operation.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Max time to wait for the operation to complete.
     * Default: `60000 milliseconds`.
     */
    timeoutInMs?: number;
    /**
     * Name of the request being performed.
     */
    requestName?: string;
}

/**
 * The standard error message accompanying an AbortError.
 * @hidden
 */
export declare const StandardAbortMessage = "The operation was aborted.";

/**
 * Maps some SystemErrors to amqp error conditions
 */
export declare enum SystemErrorConditionMapper {
    ENOTFOUND = "amqp:not-found",
    EBUSY = "com.microsoft:server-busy",
    ECONNREFUSED = "amqp:connection:forced",
    ETIMEDOUT = "com.microsoft:timeout",
    ECONNRESET = "com.microsoft:timeout",
    ENETDOWN = "com.microsoft:timeout",
    EHOSTDOWN = "com.microsoft:timeout",
    ENETRESET = "com.microsoft:timeout",
    ENETUNREACH = "com.microsoft:timeout",
    ENONET = "com.microsoft:timeout"
}

/**
 * Describes the type of supported tokens.
 */
export declare enum TokenType {
    /**
     * The "jwt" token type. Used with AADTokenCredential.
     */
    CbsTokenTypeJwt = "jwt",
    /**
     * The sas token type. Used with SharedKeyCredential.
     */
    CbsTokenTypeSas = "servicebus.windows.net:sastoken"
}

/**
 * Translates the AMQP error received at the protocol layer or a SystemError into a MessagingError.
 * All other errors are returned unaltered.
 *
 * @param err - The amqp error that was received.
 * @returns MessagingError object.
 */
export declare function translate(err: AmqpError | Error): MessagingError | Error;

/**
 * Options to configure the channelling of the AMQP connection over Web Sockets.
 */
export declare interface WebSocketOptions {
    /**
     * The WebSocket constructor used to create an AMQP connection over a WebSocket.
     * This option should be provided in the below scenarios:
     * - The TCP port 5671 which is that is used by the AMQP connection to Event Hubs is blocked in your environment.
     * - Your application needs to be run behind a proxy server.
     * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation
     *   instead of the built-in WebSocket in the browser.
     */
    webSocket?: WebSocketImpl;
    /**
     * Options to be passed to the WebSocket constructor when the underlying `rhea` library instantiates
     * the WebSocket.
     */
    webSocketConstructorOptions?: any;
}

export { }
