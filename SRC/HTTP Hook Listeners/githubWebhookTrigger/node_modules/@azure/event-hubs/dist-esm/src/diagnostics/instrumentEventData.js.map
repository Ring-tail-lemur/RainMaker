{"version":3,"file":"instrumentEventData.js","sourceRoot":"","sources":["../../../src/diagnostics/instrumentEventData.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAa,sBAAsB,EAAE,MAAM,cAAc,CAAC;AAIjE,OAAO,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,WAAW,CAAC;AAEzD;;GAEG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAC;AAEpD;;;;;;GAMG;AACH,MAAM,UAAU,mBAAmB,CACjC,SAA2C,EAC3C,OAAyB,EACzB,UAAkB,EAClB,IAAY;;IAEZ,MAAM,KAAK,GAAG,sBAAsB,CAAC,SAAS,CAAC;QAC7C,CAAC,CAAC,SAAS,CAAC,qBAAqB;QACjC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;IAEzB,mDAAmD;IACnD,MAAM,sBAAsB,GAAG,OAAO,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAG,oBAAoB,CAAC,CAAC,CAAC;IAEtE,IAAI,sBAAsB,EAAE;QAC1B,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;KACrD;IAED,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACnE,SAAS,EACT,OAAO,EACP,aAAa,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,EAAE,UAAU,CAAC,CAChD,CAAC;IACF,IAAI;QACF,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE;YAC9B,OAAO;gBACL,KAAK,EAAE,SAAS;gBAChB,WAAW,EAAE,SAAS;aACvB,CAAC;SACH;QAED,MAAM,WAAW,GAAG,aAAa,CAAC,oBAAoB,CACpD,MAAA,cAAc,CAAC,cAAc,0CAAE,cAAc,CAC9C,CAAC,aAAa,CAAC,CAAC;QACjB,IAAI,WAAW,EAAE;YACf,MAAM,WAAW,qBAAQ,KAAK,CAAE,CAAC;YAEjC,+CAA+C;YAC/C,IAAI,sBAAsB,CAAC,SAAS,CAAC,EAAE;gBACrC,SAAS,mCAAQ,SAAS,KAAE,qBAAqB,EAAE,WAAW,GAAE,CAAC;aAClE;iBAAM;gBACL,SAAS,mCAAQ,SAAS,KAAE,UAAU,EAAE,WAAW,GAAE,CAAC;aACvD;YACD,WAAW,CAAC,oBAAoB,CAAC,GAAG,WAAW,CAAC;SACjD;QAED,OAAO;YACL,KAAK,EAAE,SAAS;YAChB,WAAW,EAAE,MAAA,cAAc,CAAC,cAAc,0CAAE,cAAc;SAC3D,CAAC;KACH;YAAS;QACR,WAAW,CAAC,GAAG,EAAE,CAAC;KACnB;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,+BAA+B,CAAC,SAAoB;IAClE,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,oBAAoB,CAAC,EAAE;QACxE,OAAO;KACR;IAED,MAAM,YAAY,GAAG,SAAS,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC;IAChE,OAAO,aAAa,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;AAC5D,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData, isAmqpAnnotatedMessage } from \"../eventData\";\nimport { TracingContext } from \"@azure/core-tracing\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { OperationOptions } from \"../util/operationOptions\";\nimport { toSpanOptions, tracingClient } from \"./tracing\";\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData - The `EventData` or `AmqpAnnotatedMessage` to instrument.\n * @param span - The `Span` containing the context to propagate tracing information.\n */\nexport function instrumentEventData(\n  eventData: EventData | AmqpAnnotatedMessage,\n  options: OperationOptions,\n  entityPath: string,\n  host: string\n): { event: EventData; spanContext: TracingContext | undefined } {\n  const props = isAmqpAnnotatedMessage(eventData)\n    ? eventData.applicationProperties\n    : eventData.properties;\n\n  // check if the event has already been instrumented\n  const previouslyInstrumented = Boolean(props?.[TRACEPARENT_PROPERTY]);\n\n  if (previouslyInstrumented) {\n    return { event: eventData, spanContext: undefined };\n  }\n\n  const { span: messageSpan, updatedOptions } = tracingClient.startSpan(\n    \"message\",\n    options,\n    toSpanOptions({ entityPath, host }, \"producer\")\n  );\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        event: eventData,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions?.tracingContext\n    )[\"traceparent\"];\n    if (traceParent) {\n      const copiedProps = { ...props };\n\n      // create a copy so the original isn't modified\n      if (isAmqpAnnotatedMessage(eventData)) {\n        eventData = { ...eventData, applicationProperties: copiedProps };\n      } else {\n        eventData = { ...eventData, properties: copiedProps };\n      }\n      copiedProps[TRACEPARENT_PROPERTY] = traceParent;\n    }\n\n    return {\n      event: eventData,\n      spanContext: updatedOptions.tracingOptions?.tracingContext,\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData - An individual `EventData` object.\n * @internal\n */\nexport function extractSpanContextFromEventData(eventData: EventData): TracingContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return tracingClient.parseTraceparentHeader(diagnosticId);\n}\n"]}