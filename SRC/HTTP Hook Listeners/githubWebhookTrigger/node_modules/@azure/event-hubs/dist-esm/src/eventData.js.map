{"version":3,"file":"eventData.js","sourceRoot":"","sources":["../../src/eventData.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,oBAAoB,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AACnE,OAAO,EAAa,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AACtE,OAAO,EAIL,KAAK,GACN,MAAM,cAAc,CAAC;AACtB,OAAO,EAAE,SAAS,EAAE,sBAAsB,EAAE,iBAAiB,EAAE,MAAM,mBAAmB,CAAC;AACzF,OAAO,EACL,mCAAmC,EACnC,8BAA8B,GAC/B,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAsC,gBAAgB,EAAE,MAAM,kBAAkB,CAAC;AA+IxF,MAAM,oBAAoB,GAAG;IAC3B,UAAU,EAAE,WAAW;IACvB,OAAO,EAAE,QAAQ;IACjB,EAAE,EAAE,IAAI;IACR,OAAO,EAAE,SAAS;IAClB,QAAQ,EAAE,SAAS;IACnB,cAAc,EAAE,eAAe;IAC/B,YAAY,EAAE,aAAa;IAC3B,gBAAgB,EAAE,iBAAiB;IACnC,oBAAoB,EAAE,oBAAoB;IAC1C,aAAa,EAAE,cAAc;IAC7B,QAAQ,EAAE,SAAS;IACnB,cAAc,EAAE,eAAe;IAC/B,iBAAiB,EAAE,gBAAgB;CAC3B,CAAC;AAEX;;;;;GAKG;AACH,MAAM,UAAU,eAAe,CAC7B,GAAgB,EAChB,qBAA8B;IAE9B,MAAM,UAAU,GAAG,oBAAoB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IAC7D,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,sBAAsB,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;IAC1F,UAAU,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAE/B,MAAM,IAAI,GAAsB;QAC9B,IAAI;QACJ,iBAAiB;YACf,OAAO,UAAU,CAAC;QACpB,CAAC;KACF,CAAC;IAEF,IAAI,GAAG,CAAC,mBAAmB,EAAE;QAC3B,KAAK,MAAM,aAAa,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,EAAE;YAChE,QAAQ,aAAa,EAAE;gBACrB,KAAK,SAAS,CAAC,YAAY;oBACzB,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;oBAC3D,MAAM;gBACR,KAAK,SAAS,CAAC,cAAc;oBAC3B,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;oBAC7D,MAAM;gBACR,KAAK,SAAS,CAAC,YAAY;oBACzB,IAAI,CAAC,eAAe,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC,CAAC;oBACxE,MAAM;gBACR,KAAK,SAAS,CAAC,MAAM;oBACnB,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;oBACrD,MAAM;gBACR;oBACE,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;wBAC1B,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;qBAC5B;oBACD,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,GAAG,qBAAqB,CAC1D,GAAG,CAAC,mBAAmB,CAAC,aAAa,CAAC,CACvC,CAAC;oBACF,MAAM;aACT;SACF;KACF;IACD,IAAI,GAAG,CAAC,sBAAsB,EAAE;QAC9B,IAAI,CAAC,UAAU,GAAG,qBAAqB,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;KACrE;IACD,IAAI,GAAG,CAAC,oBAAoB,EAAE;QAC5B,IAAI,CAAC,kBAAkB,GAAG,GAAG,CAAC,oBAAoB,CAAC,oBAAoB,CAAC;QACxE,IAAI,CAAC,kBAAkB,GAAG,GAAG,CAAC,oBAAoB,CAAC,6BAA6B,CAAC;QACjF,IAAI,CAAC,gBAAgB,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,oBAAoB,CAAC,sBAAgC,CAAC,CAAC;QAC5F,IAAI,CAAC,aAAa,GAAG,IAAI,IAAI,CAC3B,GAAG,CAAC,oBAAoB,CAAC,+BAAyC,CACnE,CAAC;KACH;IAED,MAAM,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAEzD,CAAC;IACF,KAAK,MAAM,eAAe,IAAI,iBAAiB,EAAE;QAC/C,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1B,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;SAC5B;QACD,IAAI,GAAG,CAAC,eAAe,CAAC,IAAI,IAAI,EAAE;YAChC,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC,GAAG,qBAAqB,CAClF,GAAG,CAAC,eAAe,CAAC,CACrB,CAAC;SACH;KACF;IAED,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,EAAE;QAC5B,IAAI,CAAC,WAAW,GAAG,GAAG,CAAC,YAAY,CAAC;KACrC;IACD,IAAI,GAAG,CAAC,cAAc,IAAI,IAAI,EAAE;QAC9B,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC,cAAc,CAAC;KACzC;IACD,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,EAAE;QAC1B,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC,UAAU,CAAC;KACjC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,aAAa,CAC3B,IAAsC,EACtC,YAAqB;;IAErB,IAAI,WAAwB,CAAC;IAC7B,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAE;QAChC,WAAW,mCACN,oBAAoB,CAAC,aAAa,CAAC,IAAI,CAAC,KAC3C,IAAI,EAAE,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAA,IAAI,CAAC,QAAQ,mCAAI,MAAM,CAAC,GACxE,CAAC;KACH;SAAM;QACL,IAAI,QAAQ,GAAc,MAAM,CAAC;QACjC,IAAI,OAAQ,IAA0B,CAAC,iBAAiB,KAAK,UAAU,EAAE;YACvE;;;cAGE;YACF,QAAQ,GAAG,MAAC,IAA0B,CAAC,iBAAiB,EAAE,CAAC,QAAQ,mCAAI,MAAM,CAAC;SAC/E;QAED,WAAW,GAAG;YACZ,IAAI,EAAE,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC;SACzD,CAAC;QACF,kGAAkG;QAClG,2FAA2F;QAC3F,WAAW,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAErC,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,WAAW,CAAC,sBAAsB,GAAG,IAAI,CAAC,UAAU,CAAC;SACtD;QAED,IAAI,SAAS,CAAC,YAAY,CAAC,EAAE;YAC3B,WAAW,CAAC,mBAAmB,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC;YACvE,6FAA6F;YAC7F,8FAA8F;YAC9F,6EAA6E;YAC7E,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC;SAC5B;QAED,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,EAAE;YAC5B,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;SAC7C;QACD,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;YAC9B,WAAW,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC;SACjD;QACD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,EAAE;YAC1B,IACE,OAAO,IAAI,CAAC,SAAS,KAAK,QAAQ;gBAClC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,kBAAkB,EACpD;gBACA,MAAM,IAAI,KAAK,CACb,sEAAsE,SAAS,CAAC,kBAAkB,cAAc,CACjH,CAAC;aACH;YACD,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC;SACzC;KACF;IAED,OAAO,WAAW,CAAC;AACrB,CAAC;AAwHD;;GAEG;AACH,MAAM,UAAU,sBAAsB,CAAC,QAAiB;IACtD,OAAO,CACL,sBAAsB,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QACtD,CAAC,iBAAiB,CAAC,QAAQ,EAAE,mBAAmB,CAAC,CAClD,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,SAAS,qBAAqB,CAAc,KAAQ;IAClD,YAAY;IACZ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;QAAE,OAAO,KAAK,CAAC;IAEpC,2DAA2D;IAC3D,IACE,OAAO,KAAK,KAAK,QAAQ;QACzB,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC;QACnC,OAAO,KAAK,CAAC,OAAO,KAAK,UAAU,EACnC;QACA,OAAO,KAAK,CAAC,OAAO,EAAE,CAAC;KACxB;IAED;;;MAGE;IACF,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC,GAAG,CAAC,qBAAqB,CAAiB,CAAC;KACzD;IAED;;;MAGE;IACF,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;QACjD,KAAK,qBAAQ,KAAK,CAAE,CAAC;QACrB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YACnC,KAAa,CAAC,GAAG,CAAC,GAAG,qBAAqB,CAAE,KAAa,CAAC,GAAG,CAAC,CAAC,CAAC;SAClE;KACF;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAYD;;;GAGG;AACH,MAAM,UAAU,oCAAoC,CAClD,WAAwB,EACxB,EACE,6BAA6B,EAC7B,UAAU,EACV,eAAe,EACf,qBAAqB,GAC0B;IAEjD,IAAI,CAAC,6BAA6B,EAAE;QAClC,OAAO;KACR;IAED,MAAM,kBAAkB,GAAG,WAAW,CAAC,mBAAmB,IAAI,EAAE,CAAC;IACjE,IAAI,CAAC,WAAW,CAAC,mBAAmB,EAAE;QACpC,WAAW,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;KACtD;IAED,IAAI,SAAS,CAAC,UAAU,CAAC,EAAE;QACzB,kBAAkB,CAAC,mCAAmC,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;KAC9F;IACD,IAAI,SAAS,CAAC,eAAe,CAAC,EAAE;QAC9B,kBAAkB,CAAC,mCAAmC,CAAC,UAAU,CAAC;YAChE,KAAK,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;KACpC;IACD,IAAI,SAAS,CAAC,qBAAqB,CAAC,EAAE;QACpC,kBAAkB,CAAC,mCAAmC,CAAC,sBAAsB,CAAC;YAC5E,KAAK,CAAC,QAAQ,CAAC,qBAAqB,CAAC,CAAC;KACzC;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,+BAA+B,CAC7C,MAAuE;IAEvE,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE;QAC3B,MAA6B,CAAC,cAAc,EAAE,CAAC;KACjD;SAAM;QACL,iFAAiF;QACjF,8DAA8D;QAC9D,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,KAAK,CAAC,wBAAwB,GAAG,KAAK,CAAC,8BAA8B,CAAC,CAAC;YACvE,OAAO,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAC9C;KACF;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,iCAAiC,CAC/C,MAAuE;IAEvE,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE;QAC5B,yBAAyB;KAC1B;SAAM;QACL,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,OAAO,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAC9C;KACF;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { BodyTypes, defaultDataTransformer } from \"./dataTransformer\";\nimport {\n  DeliveryAnnotations,\n  MessageAnnotations,\n  Message as RheaMessage,\n  types,\n} from \"rhea-promise\";\nimport { isDefined, isObjectWithProperties, objectHasProperty } from \"./util/typeGuards\";\nimport {\n  idempotentProducerAmqpPropertyNames,\n  PENDING_PUBLISH_SEQ_NUM_SYMBOL,\n} from \"./util/constants\";\nimport { EventDataBatch, EventDataBatchImpl, isEventDataBatch } from \"./eventDataBatch\";\n\n/**\n * Describes the delivery annotations.\n * @internal\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @internal\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @internal\n */\nexport interface EventDataInternal {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset?: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n  /**\n   * The pending publish sequence number, set while the event\n   * is being published with idempotent partitions enabled.\n   */\n  [PENDING_PUBLISH_SEQ_NUM_SYMBOL]?: number;\n  /**\n   * The sequence number the event was published with\n   * when idempotent partitions are enabled.\n   */\n  _publishedSequenceNumber?: number;\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\",\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg - The AMQP message that needs to be converted to EventData.\n * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n * @internal\n */\nexport function fromRheaMessage(\n  msg: RheaMessage,\n  skipParsingBodyAsJson: boolean\n): EventDataInternal {\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);\n  const { body, bodyType } = defaultDataTransformer.decode(msg.body, skipParsingBodyAsJson);\n  rawMessage.bodyType = bodyType;\n\n  const data: EventDataInternal = {\n    body,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = convertDatesToNumbers(\n            msg.message_annotations[annotationKey]\n          );\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = convertDatesToNumbers(msg.application_properties);\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = convertDatesToNumbers(\n        msg[messageProperty]\n      );\n    }\n  }\n\n  if (msg.content_type != null) {\n    data.contentType = msg.content_type;\n  }\n  if (msg.correlation_id != null) {\n    data.correlationId = msg.correlation_id;\n  }\n  if (msg.message_id != null) {\n    data.messageId = msg.message_id;\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data - The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey - An optional key to determine the partition that this event should land in.\n * @internal\n */\nexport function toRheaMessage(\n  data: EventData | AmqpAnnotatedMessage,\n  partitionKey?: string\n): RheaMessage {\n  let rheaMessage: RheaMessage;\n  if (isAmqpAnnotatedMessage(data)) {\n    rheaMessage = {\n      ...AmqpAnnotatedMessage.toRheaMessage(data),\n      body: defaultDataTransformer.encode(data.body, data.bodyType ?? \"data\"),\n    };\n  } else {\n    let bodyType: BodyTypes = \"data\";\n    if (typeof (data as EventDataInternal).getRawAmqpMessage === \"function\") {\n      /*\n        If the event is being round-tripped, then we respect the `bodyType` of the\n        underlying AMQP message.\n      */\n      bodyType = (data as EventDataInternal).getRawAmqpMessage().bodyType ?? \"data\";\n    }\n\n    rheaMessage = {\n      body: defaultDataTransformer.encode(data.body, bodyType),\n    };\n    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n    // it is equivalent to a message-annotations section containing anempty map of annotations.\n    rheaMessage.message_annotations = {};\n\n    if (data.properties) {\n      rheaMessage.application_properties = data.properties;\n    }\n\n    if (isDefined(partitionKey)) {\n      rheaMessage.message_annotations[Constants.partitionKey] = partitionKey;\n      // Event Hub service cannot route messages to a specific partition based on the partition key\n      // if AMQP message header is an empty object. Hence we make sure that header is always present\n      // with atleast one property. Setting durable to true, helps us achieve that.\n      rheaMessage.durable = true;\n    }\n\n    if (data.contentType != null) {\n      rheaMessage.content_type = data.contentType;\n    }\n    if (data.correlationId != null) {\n      rheaMessage.correlation_id = data.correlationId;\n    }\n    if (data.messageId != null) {\n      if (\n        typeof data.messageId === \"string\" &&\n        data.messageId.length > Constants.maxMessageIdLength\n      ) {\n        throw new Error(\n          `Length of 'messageId' property on the event cannot be greater than ${Constants.maxMessageIdLength} characters.`\n        );\n      }\n      rheaMessage.message_id = data.messageId;\n    }\n  }\n\n  return rheaMessage;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n * ```\n */\nexport interface EventData {\n  /**\n   * The message body that needs to be sent.\n   * If the application reading the events is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * recieved from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    !objectHasProperty(possible, \"getRawAmqpMessage\")\n  );\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    objectHasProperty(thing, \"getTime\") &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    return thing.map(convertDatesToNumbers) as unknown as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined(thing)) {\n    thing = { ...thing };\n    for (const key of Object.keys(thing)) {\n      (thing as any)[key] = convertDatesToNumbers((thing as any)[key]);\n    }\n  }\n\n  return thing;\n}\n\n/**\n * @internal\n */\nexport interface PopulateIdempotentMessageAnnotationsParameters {\n  isIdempotentPublishingEnabled: boolean;\n  ownerLevel?: number;\n  producerGroupId?: number;\n  publishSequenceNumber?: number;\n}\n\n/**\n * Populates a rhea message with idempotent producer properties.\n * @internal\n */\nexport function populateIdempotentMessageAnnotations(\n  rheaMessage: RheaMessage,\n  {\n    isIdempotentPublishingEnabled,\n    ownerLevel,\n    producerGroupId,\n    publishSequenceNumber,\n  }: PopulateIdempotentMessageAnnotationsParameters\n): void {\n  if (!isIdempotentPublishingEnabled) {\n    return;\n  }\n\n  const messageAnnotations = rheaMessage.message_annotations || {};\n  if (!rheaMessage.message_annotations) {\n    rheaMessage.message_annotations = messageAnnotations;\n  }\n\n  if (isDefined(ownerLevel)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.epoch] = types.wrap_short(ownerLevel);\n  }\n  if (isDefined(producerGroupId)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerId] =\n      types.wrap_long(producerGroupId);\n  }\n  if (isDefined(publishSequenceNumber)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerSequenceNumber] =\n      types.wrap_int(publishSequenceNumber);\n  }\n}\n\n/**\n * Commits the pending publish sequence number events.\n * EventDataBatch exposes this as `startingPublishSequenceNumber`,\n * EventData not in a batch exposes this as `publishedSequenceNumber`.\n * @internal\n */\nexport function commitIdempotentSequenceNumbers(\n  events: Omit<EventDataInternal, \"getRawAmqpMessage\">[] | EventDataBatch\n): void {\n  if (isEventDataBatch(events)) {\n    (events as EventDataBatchImpl)._commitPublish();\n  } else {\n    // For each event, set the `publishedSequenceNumber` equal to the sequence number\n    // we set when we attempted to send the events to the service.\n    for (const event of events) {\n      event._publishedSequenceNumber = event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n      delete event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n    }\n  }\n}\n\n/**\n * Rolls back any pending publish sequence number in the events.\n * @internal\n */\nexport function rollbackIdempotentSequenceNumbers(\n  events: Omit<EventDataInternal, \"getRawAmqpMessage\">[] | EventDataBatch\n): void {\n  if (isEventDataBatch(events)) {\n    /* No action required. */\n  } else {\n    for (const event of events) {\n      delete event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n    }\n  }\n}\n"]}