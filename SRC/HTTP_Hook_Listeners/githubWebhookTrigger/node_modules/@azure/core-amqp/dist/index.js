'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var abortController = require('@azure/abort-controller');
var rheaPromise = require('rhea-promise');
var logger$1 = require('@azure/logger');
var dns = require('dns');
var os = require('os');
var coreAuth = require('@azure/core-auth');
var jssha = require('jssha');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var os__namespace = /*#__PURE__*/_interopNamespace(os);
var jssha__default = /*#__PURE__*/_interopDefaultLegacy(jssha);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * Note: The properties may be inherited.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 * @internal
 */
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
        return false;
    }
    for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
            return false;
        }
    }
    return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * Note: The property may be inherited.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 * @internal
 */
function objectHasProperty(thing, property) {
    return typeof thing === "object" && property in thing;
}
/**
 * Typeguard that checks if the input is a SasTokenProvider.
 * @param thing - Any object.
 * @hidden
 */
function isSasTokenProvider(thing) {
    return isObjectWithProperties(thing, ["isSasTokenProvider"]) && thing.isSasTokenProvider === true;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const Constants = {
    associatedLinkName: "associated-link-name",
    partitionKey: "x-opt-partition-key",
    sequenceNumber: "x-opt-sequence-number",
    enqueueSequenceNumber: "x-opt-enqueue-sequence-number",
    enqueuedTime: "x-opt-enqueued-time",
    scheduledEnqueueTime: "x-opt-scheduled-enqueue-time",
    offset: "x-opt-offset",
    lockedUntil: "x-opt-locked-until",
    partitionIdName: "x-opt-partition-id",
    publisher: "x-opt-publisher-name",
    viaPartitionKey: "x-opt-via-partition-key",
    deadLetterSource: "x-opt-deadletter-source",
    messageState: "x-opt-message-state",
    enqueuedTimeAnnotation: `amqp.annotation.x-opt-enqueued-time`,
    offsetAnnotation: `amqp.annotation.x-opt-offset`,
    sequenceNumberAnnotation: `amqp.annotation.x-opt-sequence-number`,
    guidSize: 16,
    message: "message",
    error: "error",
    statusCode: "status-code",
    statusDescription: "status-description",
    errorCondition: "error-condition",
    management: "$management",
    partition: "partition",
    partitionId: "partitionId",
    readOperation: "READ",
    TLS: "tls",
    establishConnection: "establishConnection",
    defaultConsumerGroup: "$default",
    eventHub: "eventhub",
    cbsEndpoint: "$cbs",
    cbsReplyTo: "cbs",
    operationPutToken: "put-token",
    aadEventHubsAudience: "https://eventhubs.azure.net/",
    aadEventHubsScope: "https://eventhubs.azure.net//.default",
    aadServiceBusAudience: "https://servicebus.azure.net/",
    aadServiceBusScope: "https://servicebus.azure.net//.default",
    maxUserAgentLength: 512,
    vendorString: "com.microsoft",
    attachEpoch: `com.microsoft:epoch`,
    receiverIdentifierName: `com.microsoft:receiver-name`,
    enableReceiverRuntimeMetricName: `com.microsoft:enable-receiver-runtime-metric`,
    timespan: `com.microsoft:timespan`,
    uri: `com.microsoft:uri`,
    dateTimeOffset: `com.microsoft:datetime-offset`,
    sessionFilterName: `com.microsoft:session-filter`,
    receiverError: "receiver_error",
    senderError: "sender_error",
    sessionError: "session_error",
    connectionError: "connection_error",
    defaultOperationTimeoutInMs: 60000,
    defaultConnectionIdleTimeoutInMs: 60000,
    managementRequestKey: "managementRequest",
    negotiateCbsKey: "negotiateCbs",
    negotiateClaim: "negotiateClaim",
    ensureContainerAndBlob: "ensureContainerAndBlob",
    defaultPrefetchCount: 1000,
    reconnectLimit: 100,
    maxMessageIdLength: 128,
    maxPartitionKeyLength: 128,
    maxSessionIdLength: 128,
    pathDelimiter: "/",
    ruleNameMaximumLength: 50,
    maximumSqlFilterStatementLength: 1024,
    maximumSqlRuleActionStatementLength: 1024,
    maxDeadLetterReasonLength: 4096,
    // https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
    // However we are setting this to the TimeSpan.MaxValue of C#.
    maxDurationValue: 922337203685477,
    minDurationValue: -922337203685477,
    // https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
    maxAbsoluteExpiryTime: new Date("9999-12-31T07:59:59.000Z").getTime(),
    aadTokenValidityMarginInMs: 5000,
    connectionReconnectDelay: 300,
    defaultMaxRetries: 3,
    defaultMaxRetriesForConnection: 150,
    defaultDelayBetweenOperationRetriesInMs: 30000,
    defaultMaxDelayForExponentialRetryInMs: 90000,
    receiverSettleMode: "receiver-settle-mode",
    dispositionStatus: "disposition-status",
    fromSequenceNumber: "from-sequence-number",
    messageCount: "message-count",
    lockTokens: "lock-tokens",
    messageIdMapKey: "message-id",
    sequenceNumberMapKey: "sequence-number",
    lockTokenMapKey: "lock-token",
    sessionIdMapKey: "session-id",
    sequenceNumbers: "sequence-numbers",
    deadLetterReason: "deadletter-reason",
    deadLetterDescription: "deadletter-description",
    propertiesToModify: "properties-to-modify",
    deadLetterName: "com.microsoft:dead-letter",
    trackingId: "com.microsoft:tracking-id",
    serverTimeout: "com.microsoft:server-timeout",
    operations: {
        putToken: "put-token",
        read: "READ",
        cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
        scheduleMessage: "com.microsoft:schedule-message",
        renewLock: "com.microsoft:renew-lock",
        peekMessage: "com.microsoft:peek-message",
        receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
        updateDisposition: "com.microsoft:update-disposition",
        renewSessionLock: "com.microsoft:renew-session-lock",
        setSessionState: "com.microsoft:set-session-state",
        getSessionState: "com.microsoft:get-session-state",
        enumerateSessions: "com.microsoft:get-message-sessions",
        addRule: "com.microsoft:add-rule",
        removeRule: "com.microsoft:remove-rule",
        enumerateRules: "com.microsoft:enumerate-rules",
    },
    descriptorCodes: {
        ruleDescriptionList: 1335734829060,
        sqlFilterList: 83483426822,
        correlationFilterList: 83483426825,
        sqlRuleActionList: 1335734829062,
        trueFilterList: 83483426823,
        falseFilterList: 83483426824,
    },
};
/**
 * The standard error message accompanying an AbortError.
 * @hidden
 */
const StandardAbortMessage = "The operation was aborted.";

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
const logger = logger$1.createClientLogger("core-amqp");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error - Error containing a stack trace.
 * @internal
 */
function logErrorStackTrace(error) {
    if (isObjectWithProperties(error, ["stack"])) {
        logger.verbose(error.stack);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * This class is used to coordinate executing tasks that should not be run in parallel.
 * @internal
 */
class CancellableAsyncLockImpl {
    constructor() {
        this._keyMap = new Map();
        this._executionRunningSet = new Set();
    }
    /**
     * Returns a promise that resolves to the value returned by the provided task function.
     * Only 1 task can be invoked at a time for a given `key` value.
     *
     * An acquire call can be cancelled via an `abortSignal`.
     * If cancelled, the promise will be rejected with an `AbortError`.
     *
     * `acquireTimeoutInMs` can also be provided to properties.
     * If the timeout is reached before the provided `task` is invoked,
     * then the promise will be rejected with an Error stating the task
     * timed out waiting to acquire a lock.
     *
     * @param key - All `acquire` calls are grouped by the provided `key`.
     * @param task - The function to invoke once the lock has been acquired.
     * @param properties - Additional properties to control the behavior of `acquire`.
     */
    acquire(key, task, properties) {
        var _a;
        const { abortSignal, timeoutInMs } = properties;
        // Fast exit if the operation is already cancelled.
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            return Promise.reject(new abortController.AbortError(StandardAbortMessage));
        }
        // Ensure we've got a task queue for the given key.
        const taskQueue = (_a = this._keyMap.get(key)) !== null && _a !== void 0 ? _a : [];
        this._keyMap.set(key, taskQueue);
        // This method will return a promise that will be fulfilled outside this function.
        const { promise, rejecter, resolver } = getPromiseParts();
        const taskDetails = {
            reject: rejecter,
            resolve: resolver,
            task,
        };
        // Handle timeouts by removing the task from the queue when hit.
        if (typeof timeoutInMs === "number") {
            const tid = setTimeout(() => {
                this._removeTaskDetails(key, taskDetails);
                rejecter(new rheaPromise.OperationTimeoutError(`The task timed out waiting to acquire a lock for ${key}`));
            }, timeoutInMs);
            taskDetails.tid = tid;
        }
        // Handle cancellation by removing the task from the queue when cancelled.
        if (abortSignal) {
            const abortListener = () => {
                this._removeTaskDetails(key, taskDetails);
                rejecter(new abortController.AbortError(StandardAbortMessage));
            };
            abortSignal.addEventListener("abort", abortListener);
            taskDetails.abortSignal = abortSignal;
            taskDetails.abortListener = abortListener;
        }
        // Enqueue the task!
        taskQueue.push(taskDetails);
        logger.verbose(`Called acquire() for lock "${key}". Lock "${key}" has ${taskQueue.length} pending tasks.`);
        // Start a loop to iterate over the task queue.
        // This will run asynchronously and won't allow
        // more than 1 concurrent execution per key at a time.
        this._execute(key);
        return promise;
    }
    /**
     * Iterates over all the pending tasks for a given `key` serially.
     *
     * Note: If the pending tasks are already being iterated by an early
     * _execute invocation, this returns immediately.
     * @returns
     */
    async _execute(key) {
        // If the key already exists in the set, then exit because
        // tasks are already being processed.
        if (this._executionRunningSet.has(key)) {
            return;
        }
        const taskQueue = this._keyMap.get(key);
        // If the queue is empty, exit early!
        if (!taskQueue || !taskQueue.length) {
            return;
        }
        // Add the key to the set so we can tell the
        // task queue is already being processed.
        this._executionRunningSet.add(key);
        while (taskQueue.length) {
            // Remove tasks from the front of the queue.
            // Order matters!
            const taskDetails = taskQueue.shift();
            if (!taskDetails) {
                continue;
            }
            try {
                logger.verbose(`Acquired lock for "${key}", invoking task.`);
                cleanupTaskDetails(taskDetails);
                const value = await taskDetails.task();
                taskDetails.resolve(value);
            }
            catch (err) {
                taskDetails.reject(err);
            }
            logger.verbose(`Task completed for lock "${key}". Lock "${key}" has ${taskQueue.length} pending tasks.`);
        }
        // Indicate that the task queue for the key is empty
        // and we're done processing it.
        this._executionRunningSet.delete(key);
    }
    _removeTaskDetails(key, taskDetails) {
        const taskQueue = this._keyMap.get(key);
        if (!taskQueue || !taskQueue.length) {
            // The task is already gone from the queue, so our work here is done!
            return;
        }
        const index = taskQueue.indexOf(taskDetails);
        if (index !== -1) {
            const [details] = taskQueue.splice(index, 1);
            // Cleanup the task rejection code paths.
            cleanupTaskDetails(details);
        }
    }
}
/**
 * @internal
 * Returns a promise and the promise's resolve and reject methods.
 */
function getPromiseParts() {
    let resolver;
    let rejecter;
    const promise = new Promise((resolve, reject) => {
        resolver = resolve;
        rejecter = reject;
    });
    return {
        promise,
        resolver: resolver,
        rejecter: rejecter,
    };
}
/**
 * @internal
 * Removes any abort listener or pending timeout from a task.
 */
function cleanupTaskDetails(taskDetails) {
    // Cleanup the task rejection code paths.
    if (taskDetails.tid)
        clearTimeout(taskDetails.tid);
    if (taskDetails.abortSignal && taskDetails.abortListener) {
        taskDetails.abortSignal.removeEventListener("abort", taskDetails.abortListener);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
/**
 * @internal
 *
 * A constant that indicates whether the environment is node.js or browser based.
 */
const isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);
/**
 * Parses the connection string and returns an object of type T.
 *
 * Connection strings have the following syntax:
 *
 * ConnectionString ::= `Part { ";" Part } [ ";" ] [ WhiteSpace ]`
 * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
 * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
 * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
 * WhiteSpace       ::= ? all whitespace characters including `\r` and `\n` ?
 *
 * @param connectionString - The connection string to be parsed.
 * @returns ParsedOutput<T>.
 */
function parseConnectionString(connectionString) {
    const output = {};
    const parts = connectionString.trim().split(";");
    for (let part of parts) {
        part = part.trim();
        if (part === "") {
            // parts can be empty
            continue;
        }
        const splitIndex = part.indexOf("=");
        if (splitIndex === -1) {
            throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
        }
        const key = part.substring(0, splitIndex).trim();
        if (key === "") {
            throw new Error("Connection string malformed: missing key for assignment");
        }
        const value = part.substring(splitIndex + 1).trim();
        output[key] = value;
    }
    return output;
}
/**
 * The cancellable async lock instance.
 */
const defaultCancellableLock = new CancellableAsyncLockImpl();
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param delayInMs - The number of milliseconds to be delayed.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns - Resolved promise
 */
function delay(delayInMs, abortSignal, abortErrorMsg, value) {
    return new Promise((resolve, reject) => {
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = () => {
            return reject(new abortController.AbortError(abortErrorMsg ? abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
            if (abortSignal && onAborted) {
                abortSignal.removeEventListener("abort", onAborted);
            }
        };
        onAborted = () => {
            if (isDefined(timer)) {
                clearTimeout(timer);
            }
            removeListeners();
            return rejectOnAbort();
        };
        if (abortSignal && abortSignal.aborted) {
            return rejectOnAbort();
        }
        timer = setTimeout(() => {
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (abortSignal) {
            abortSignal.addEventListener("abort", onAborted);
        }
    });
}
/**
 * @internal
 */
function isString(s) {
    return typeof s === "string";
}
/**
 * @internal
 */
function isNumber(n) {
    return typeof n === "number";
}

// Copyright (c) Microsoft Corporation.
/**
 * Maps the conditions to the numeric AMQP Response status codes.
 * @internal
 */
var ConditionStatusMapper;
(function (ConditionStatusMapper) {
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
    ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
    ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
})(ConditionStatusMapper || (ConditionStatusMapper = {}));
/**
 * Maps the amqp error conditions to the Error names.
 */
exports.ConditionErrorNameMapper = void 0;
(function (ConditionErrorNameMapper) {
    /**
     * Error is thrown when the address is already in use.
     */
    ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
    /**
     * Error is thrown when the store lock is lost.
     */
    ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
    /**
     * Error is thrown when a matching subscription is not found.
     */
    ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */
    ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
    /**
     * Error is thrown when the lock on the message is lost.
     */
    ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */
    ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
    /**
     * Error is thrown when the message is not found.
     */
    ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
    /**
     * Error is thrown when relay is not found.
     */
    ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when data could not be decoded.
     */
    ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
     */
    ConditionErrorNameMapper["system:error"] = "SystemError";
})(exports.ConditionErrorNameMapper || (exports.ConditionErrorNameMapper = {}));
/**
 * Maps the Error names to the amqp error conditions.
 */
exports.ErrorNameConditionMapper = void 0;
(function (ErrorNameConditionMapper) {
    /**
     * Error is thrown when the address is already in use.
     */
    ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
    /**
     * Error is thrown when the store lock is lost.
     */
    ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
    /**
     * Error is thrown when a matching subscription is not found.
     */
    ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */
    ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
    /**
     * Error is thrown when the lock on the message is lost.
     */
    ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */
    ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
    /**
     * Error is thrown when message is not found.
     */
    ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
    /**
     * Error is thrown when relay is not found.
     */
    ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
    /**
     * Error is thrown when data could not be decoded.
     */
    ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
     */
    ErrorNameConditionMapper["SystemError"] = "system:error";
})(exports.ErrorNameConditionMapper || (exports.ErrorNameConditionMapper = {}));
/**
 * @internal
 */
const systemErrorFieldsToCopy = [
    "address",
    "code",
    "errno",
    "info",
    "port",
    "stack",
    "syscall",
];
/**
 * Determines if an error is a MessagingError.
 *
 * @param error - An error that can either be an Error or a MessagingError.
 */
function isMessagingError(error) {
    return error.name === "MessagingError";
}
/**
 * Describes the base class for Messaging Error.
 */
class MessagingError extends Error {
    /**
     * @param message - The error message that provides more information about the error.
     * @param originalError - An error whose properties will be copied to the MessagingError if the
     * property matches one found on the Node.js `SystemError`.
     */
    constructor(message, originalError) {
        super(message);
        /**
         * The error name. Default value: "MessagingError".
         */
        this.name = "MessagingError";
        /**
         *
         * Describes whether the error is retryable. Default: true.
         */
        this.retryable = true;
        if (!originalError) {
            return;
        }
        // copy properties from system error
        for (const propName of systemErrorFieldsToCopy) {
            if (originalError[propName] != undefined) {
                this[propName] = originalError[propName];
            }
        }
    }
}
/**
 * Provides a list of retryable AMQP errors.
 * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
 * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
 * "TransferLimitExceededError"
 */
const retryableErrors = [
    "InternalServerError",
    "ServerBusyError",
    "ServiceUnavailableError",
    "OperationCancelledError",
    // The service may throw UnauthorizedError if credentials have been rotated.
    // Attempt to retry in case the user has also rotated their credentials.
    "UnauthorizedError",
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    // Since reasons for such failures can be transient, this is treated as a retryable error.
    "OperationTimeoutError",
    "SenderBusyError",
    "MessagingError",
    "DetachForcedError",
    "ConnectionForcedError",
    "TransferLimitExceededError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    // Since reasons for such shortage can be transient such as for pending delivery of messages, this is treated as a retryable error.
    "InsufficientCreditError",
];
/**
 * Maps some SystemErrors to amqp error conditions
 */
exports.SystemErrorConditionMapper = void 0;
(function (SystemErrorConditionMapper) {
    SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
    SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
    SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
    SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
})(exports.SystemErrorConditionMapper || (exports.SystemErrorConditionMapper = {}));
/**
 * Checks whether the provided error is a node.js SystemError.
 * @param err - An object that may contain error information.
 */
function isSystemError(err) {
    if (!isObjectWithProperties(err, ["code", "syscall", "errno"])) {
        return false;
    }
    if (!isString(err.code) || !isString(err.syscall)) {
        return false;
    }
    if (!isString(err.errno) && !isNumber(err.errno)) {
        return false;
    }
    return true;
}
/**
 * @internal
 * Since browser doesn't differentiate between the various kinds of service communication errors,
 * this utility is used to look at the error target to identify such category of errors.
 * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
 * @param err - object that may contain error information
 */
function isBrowserWebsocketError(err) {
    let result = false;
    if (!isNode && self && err.type === "error" && err.target instanceof self.WebSocket) {
        result = true;
    }
    return result;
}
/**
 * @internal
 */
const rheaPromiseErrors = [
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    "OperationTimeoutError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    "InsufficientCreditError",
    // Defines the error that occurs when the Sender fails to send a message.
    "SendOperationFailedError",
];
/**
 * Translates the AMQP error received at the protocol layer or a SystemError into a MessagingError.
 * All other errors are returned unaltered.
 *
 * @param err - The amqp error that was received.
 * @returns MessagingError object.
 */
function translate(err) {
    if (!isDefined(err)) {
        return new Error(`Unknown error encountered.`);
    }
    else if (typeof err !== "object") {
        // The error is a scalar type, make it the message of an actual error.
        return new Error(err);
    }
    // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
    // with user input and not an issue with the Messaging process.
    if (err instanceof TypeError || err instanceof RangeError) {
        return err;
    }
    if (isAmqpError(err)) {
        // translate
        const condition = err.condition;
        const description = err.description;
        const error = new MessagingError(description);
        if (err.stack)
            error.stack = err.stack;
        error.info = err.info;
        if (condition) {
            error.code = exports.ConditionErrorNameMapper[condition];
        }
        if (description &&
            (description.includes("status-code: 404") ||
                description.match(/The messaging entity .* could not be found.*/i) !== null)) {
            error.code = "MessagingEntityNotFoundError";
        }
        if (error.code && retryableErrors.indexOf(error.code) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    if (err.name === "MessagingError") {
        // already translated
        return err;
    }
    if (isSystemError(err)) {
        // translate
        const condition = err.code;
        const description = err.message;
        const error = new MessagingError(description, err);
        let errorType = "SystemError";
        if (condition) {
            const amqpErrorCondition = exports.SystemErrorConditionMapper[condition];
            errorType =
                exports.ConditionErrorNameMapper[amqpErrorCondition];
        }
        if (retryableErrors.indexOf(errorType) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    if (isBrowserWebsocketError(err)) {
        // Translate browser communication errors during opening handshake to generic ServiceCommunicationError
        const error = new MessagingError("Websocket connection failed.");
        error.code = exports.ConditionErrorNameMapper[exports.ErrorNameConditionMapper.ServiceCommunicationError];
        error.retryable = false;
        return error;
    }
    // Some errors come from rhea-promise and need to be converted to MessagingError.
    // A subset of these are also retryable.
    if (rheaPromiseErrors.indexOf(err.name) !== -1) {
        const error = new MessagingError(err.message, err);
        error.code = err.name;
        if (error.code && retryableErrors.indexOf(error.code) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    return err;
}
/**
 * @internal
 */
function isAmqpError(error) {
    return rheaPromise.isAmqpError(error);
}

// Copyright (c) Microsoft Corporation.
/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 */
class RequestResponseLink {
    /**
     * @param session - The amqp session.
     * @param sender - The amqp sender link.
     * @param receiver - The amqp receiver link.
     */
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        /**
         * Maintains a map of responses that
         * are being actively returned. It acts as a store for correlating the responses received for
         * the send requests.
         */
        this._responsesMap = new Map();
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.receiver.on(rheaPromise.ReceiverEvents.message, (context) => {
            onMessageReceived(context, this.connection.id, this._responsesMap);
        });
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns Connection.
     */
    get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param request - The AMQP (request) message.
     * @param options - Options that can be provided while sending a request.
     * @returns Promise<Message> The AMQP (response) message.
     */
    sendRequest(request, options = {}) {
        const timeoutInMs = options.timeoutInMs || Constants.defaultOperationTimeoutInMs;
        const aborter = options.abortSignal;
        // If message_id is not already set on the request, set it to a unique value
        // This helps in determining the right response for current request among multiple incoming messages
        if (!request.message_id) {
            request.message_id = rheaPromise.generate_uuid();
        }
        return new Promise((resolve, reject) => {
            let timer = undefined;
            const rejectOnAbort = () => {
                this._responsesMap.delete(request.message_id);
                const address = this.receiver.address || "address";
                const requestName = options.requestName;
                const desc = `[${this.connection.id}] The request "${requestName}" ` +
                    `to "${address}" has been cancelled by the user.`;
                // Cancellation is a user-intended action, so log to info instead of warning.
                logger.info(desc);
                const error = new abortController.AbortError(StandardAbortMessage);
                reject(error);
            };
            const onAbort = () => {
                // safe to clear the timeout if it hasn't already occurred.
                if (isDefined(timer)) {
                    clearTimeout(timer);
                }
                aborter.removeEventListener("abort", onAbort);
                rejectOnAbort();
            };
            if (aborter) {
                // the aborter may have been triggered between request attempts
                // so check if it was triggered and reject if needed.
                if (aborter.aborted) {
                    return rejectOnAbort();
                }
                aborter.addEventListener("abort", onAbort);
            }
            timer = setTimeout(() => {
                this._responsesMap.delete(request.message_id);
                if (aborter) {
                    aborter.removeEventListener("abort", onAbort);
                }
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc,
                };
                return reject(translate(e));
            }, timeoutInMs);
            this._responsesMap.set(request.message_id, {
                resolve: resolve,
                reject: reject,
                cleanupBeforeResolveOrReject: () => {
                    if (aborter)
                        aborter.removeEventListener("abort", onAbort);
                    if (isDefined(timer)) {
                        clearTimeout(timer);
                    }
                },
            });
            logger.verbose("[%s] %s request sent: %O", this.connection.id, request.to || "$management", request);
            this.sender.send(request);
        });
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns Promise<void>
     */
    async close() {
        await this.sender.close({ closeSession: false });
        await this.receiver.close({ closeSession: false });
        await this.session.close();
    }
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns void
     */
    remove() {
        this.sender.remove();
        this.receiver.remove();
        this.session.remove();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param connection - The amqp connection.
     * @param senderOptions - Options that must be provided to create the sender link.
     * @param receiverOptions - Options that must be provided to create the receiver link.
     * @param createOptions - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `create` invocation.
     * @returns Promise<RequestResponseLink>
     */
    static async create(connection, senderOptions, receiverOptions, createOptions = {}) {
        const { abortSignal } = createOptions;
        const session = await connection.createSession({ abortSignal });
        const sender = await session.createSender(Object.assign(Object.assign({}, senderOptions), { abortSignal }));
        const receiver = await session.createReceiver(Object.assign(Object.assign({}, receiverOptions), { abortSignal }));
        logger.verbose("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
        return new RequestResponseLink(session, sender, receiver);
    }
}
/**
 * @internal
 *
 * Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
 */
const getCodeDescriptionAndError = (props = {}) => {
    return {
        statusCode: (props[Constants.statusCode] || props.statusCode),
        statusDescription: (props[Constants.statusDescription] || props.statusDescription),
        errorCondition: (props[Constants.errorCondition] || props.errorCondition),
    };
};
/**
 * This is used as the onMessage handler for the "message" event on the receiver.
 *
 * (This is inspired from the message settlement sequence in service-bus SDK which
 * relies on a single listener for settled event for all the messages.)
 * The sequence is as follows:
 * 1. User calls `await RequestResponseLink.sendRequest()`
 * 2. This creates a `Promise` that gets stored in the _responsesMap
 * 3. When the service acknowledges the response, this method gets called for that request.
 * 4. We resolve() the promise from the _responsesMap with the message.
 * 5. User's code after the sendRequest continues.
 *
 * @internal
 */
function onMessageReceived(context, connectionId, responsesMap) {
    const message = context.message;
    if (!message) {
        logger.verbose(`[${connectionId}] "message" property on the EventContext is "undefined" which is unexpected, ` +
            `returning from the "onMessageReceived" handler without resolving or rejecting the promise ` +
            `upon encountering the message event.`);
        return;
    }
    const responseCorrelationId = message.correlation_id;
    if (!responsesMap.has(responseCorrelationId)) {
        logger.verbose(`[${connectionId}] correlationId "${responseCorrelationId}" property on the response does not match with ` +
            `any of the "request-id"s in the map, returning from the "onMessageReceived" handler without resolving ` +
            `or rejecting the promise upon encountering the message event.`);
        return;
    }
    const promise = responsesMap.get(responseCorrelationId);
    promise.cleanupBeforeResolveOrReject();
    const deleteResult = responsesMap.delete(responseCorrelationId);
    logger.verbose(`[${connectionId}] Successfully deleted the response with id ${responseCorrelationId} from the map. ` +
        `Delete result - ${deleteResult}`);
    const info = getCodeDescriptionAndError(message.application_properties);
    let error;
    if (!info.statusCode) {
        error = new Error(`[${connectionId}] No statusCode in the "application_properties" in the returned response with correlation-id: ${responseCorrelationId}`);
    }
    if (info.statusCode > 199 && info.statusCode < 300) {
        logger.verbose(`[${connectionId}] Resolving the response with correlation-id: ${responseCorrelationId}`);
        return promise.resolve(message);
    }
    if (!error) {
        const condition = info.errorCondition || ConditionStatusMapper[info.statusCode] || "amqp:internal-error";
        error = translate({
            condition: condition,
            description: info.statusDescription,
        });
        logger.warning(`${error === null || error === void 0 ? void 0 : error.name}: ${error === null || error === void 0 ? void 0 : error.message}`);
    }
    logErrorStackTrace(error);
    return promise.reject(error);
}

// Copyright (c) Microsoft Corporation.
/**
 * Checks whether a network connection is detected.
 * @internal
 */
function checkNetworkConnection(host) {
    return new Promise((resolve) => {
        logger.verbose("Calling dns.resolve to determine network connection status.");
        dns.resolve(host, function (err) {
            if (err) {
                logger.verbose("Error thrown from dns.resolve in network connection check: '%s', %O", err.code || err.name, err);
                // List of possible DNS error codes: https://nodejs.org/dist/latest-v12.x/docs/api/dns.html#dns_error_codes
                // We only resolve with `false` when dnsResolve fails with an error we expect to see when the network is down.
                if (err.code === dns.CONNREFUSED || err.code === dns.TIMEOUT) {
                    return resolve(false);
                }
            }
            else {
                logger.verbose("Successfully resolved host via dns.resolve in network connection check.");
            }
            return resolve(true);
        });
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Determines whether the object is a Delivery object.
 * @internal
 */
function isDelivery(obj) {
    let result = false;
    if (obj &&
        typeof obj.id === "number" &&
        typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" &&
        typeof obj.format === "number") {
        result = true;
    }
    return result;
}
/**
 * Describes the Retry Mode type
 */
exports.RetryMode = void 0;
(function (RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})(exports.RetryMode || (exports.RetryMode = {}));
/**
 * Describes the retry operation type.
 */
exports.RetryOperationType = void 0;
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["receiveMessage"] = "receiveMessage";
    RetryOperationType["session"] = "session";
    RetryOperationType["messageSettlement"] = "settlement";
})(exports.RetryOperationType || (exports.RetryOperationType = {}));
/**
 * Validates the retry config.
 * @internal
 */
function validateRetryConfig(config) {
    if (!config.operation) {
        throw new TypeError("Missing 'operation' in retry configuration");
    }
    if (!config.connectionId) {
        throw new TypeError("Missing 'connectionId' in retry configuration");
    }
    if (!config.operationType) {
        throw new TypeError("Missing 'operationType' in retry configuration");
    }
}
/**
 * Calculates delay between retries, in milliseconds.
 * @internal
 */
function calculateDelay(attemptCount, retryDelayInMs, maxRetryDelayInMs, mode) {
    if (mode === exports.RetryMode.Exponential) {
        const boundedRandDelta = retryDelayInMs * 0.8 +
            Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));
        const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);
        return Math.min(incrementDelta, maxRetryDelayInMs);
    }
    return retryDelayInMs;
}
/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param config - Parameters to configure retry operation
 *
 * @returns Promise<T>.
 */
async function retry(config) {
    validateRetryConfig(config);
    if (!config.retryOptions) {
        config.retryOptions = {};
    }
    if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) {
        config.retryOptions.maxRetries = Constants.defaultMaxRetries;
    }
    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
        config.retryOptions.retryDelayInMs = Constants.defaultDelayBetweenOperationRetriesInMs;
    }
    if (config.retryOptions.maxRetryDelayInMs == undefined ||
        config.retryOptions.maxRetryDelayInMs < 0) {
        config.retryOptions.maxRetryDelayInMs = Constants.defaultMaxDelayForExponentialRetryInMs;
    }
    if (config.retryOptions.mode == undefined) {
        config.retryOptions.mode = exports.RetryMode.Fixed;
    }
    let lastError;
    let result;
    let success = false;
    const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;
    for (let i = 1; i <= totalNumberOfAttempts; i++) {
        logger.verbose("[%s] Attempt number for '%s': %d.", config.connectionId, config.operationType, i);
        try {
            result = await config.operation();
            success = true;
            logger.verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);
            if (result && !isDelivery(result)) {
                logger.verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
            }
            break;
        }
        catch (_err) {
            let err = _err;
            if (!err.translated) {
                err = translate(err);
            }
            if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                const isConnected = await checkNetworkConnection(config.connectionHost);
                if (!isConnected) {
                    err.name = "ConnectionLostError";
                    err.retryable = true;
                }
            }
            lastError = err;
            logger.verbose("[%s] Error occurred for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);
            if (lastError && lastError.retryable && totalNumberOfAttempts > i) {
                const targetDelayInMs = calculateDelay(i, config.retryOptions.retryDelayInMs, config.retryOptions.maxRetryDelayInMs, config.retryOptions.mode);
                logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);
                await delay(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
                continue;
            }
            else {
                break;
            }
        }
    }
    if (success) {
        return result;
    }
    else {
        throw lastError;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Describes the type of supported tokens.
 */
exports.TokenType = void 0;
(function (TokenType) {
    /**
     * The "jwt" token type. Used with AADTokenCredential.
     */
    TokenType["CbsTokenTypeJwt"] = "jwt";
    /**
     * The sas token type. Used with SharedKeyCredential.
     */
    TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
})(exports.TokenType || (exports.TokenType = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Describes the ConnectionConfig module
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.
const ConnectionConfig = {
    /**
     * Creates the connection config.
     * @param connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param path - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns ConnectionConfig
     */
    create(connectionString, path) {
        connectionString = String(connectionString);
        const parsedCS = parseConnectionString(connectionString);
        if (!parsedCS.Endpoint) {
            throw new TypeError("Missing Endpoint in Connection String.");
        }
        if (!parsedCS.Endpoint.endsWith("/"))
            parsedCS.Endpoint += "/";
        const result = {
            connectionString: connectionString,
            endpoint: parsedCS.Endpoint,
            host: parsedCS && parsedCS.Endpoint ? (parsedCS.Endpoint.match(".*://([^/]*)") || [])[1] : "",
            sharedAccessKeyName: parsedCS.SharedAccessKeyName,
            sharedAccessKey: parsedCS.SharedAccessKey,
        };
        if (path || parsedCS.EntityPath) {
            result.entityPath = path || parsedCS.EntityPath;
        }
        return result;
    },
    /**
     * Validates the properties of connection config.
     * @param config - The connection config to be validated.
     * @returns void
     */
    validate(config, options) {
        if (!options)
            options = {};
        if (!config) {
            throw new TypeError("Missing configuration");
        }
        if (!config.endpoint) {
            throw new TypeError("Missing 'endpoint' in configuration");
        }
        config.endpoint = String(config.endpoint);
        if (!config.host) {
            throw new TypeError("Missing 'host' in configuration");
        }
        config.host = String(config.host);
        if (options.isEntityPathRequired && !config.entityPath) {
            throw new TypeError("Missing 'entityPath' in configuration");
        }
        if (isDefined(config.entityPath)) {
            config.entityPath = String(config.entityPath);
        }
        if (!isSharedAccessSignature(config.connectionString)) {
            if (!config.sharedAccessKeyName) {
                throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            }
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) {
                throw new TypeError("Missing 'sharedAccessKey' in configuration");
            }
            config.sharedAccessKey = String(config.sharedAccessKey);
        }
    },
};
/**
 * @internal
 */
function isSharedAccessSignature(connectionString) {
    return connectionString.match(/;{0,1}SharedAccessSignature=SharedAccessSignature /) != null;
}

// Copyright (c) Microsoft Corporation.
/**
 * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endpoint over AMQP connection.
 */
class CbsClient {
    /**
     * @param connection - The AMQP connection.
     * @param connectionLock - A unique string (usually a guid) per connection.
     */
    constructor(connection, connectionLock) {
        /**
         * CBS endpoint - "$cbs"
         */
        this.endpoint = Constants.cbsEndpoint;
        /**
         * CBS replyTo - The receiver link name that the service should reply to.
         */
        this.replyTo = `${Constants.cbsReplyTo}-${rheaPromise.generate_uuid()}`;
        /**
         * The unique lock name per $cbs session per connection that is used to
         * acquire the lock for establishing a cbs session if one does not exist for an amqp connection.
         */
        this.cbsLock = `${Constants.negotiateCbsKey}-${rheaPromise.generate_uuid()}`;
        this.connection = connection;
        this.connectionLock = connectionLock;
    }
    /**
     * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
     * the given connection.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `init` invocation.
     * @returns Promise<void>.
     */
    async init(options = {}) {
        const { abortSignal, timeoutInMs } = options;
        try {
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                throw new abortController.AbortError(StandardAbortMessage);
            }
            // Acquire the lock and establish an amqp connection if it does not exist.
            if (!this.connection.isOpen()) {
                logger.verbose("The CBS client is trying to establish an AMQP connection.");
                await defaultCancellableLock.acquire(this.connectionLock, () => {
                    return this.connection.open({ abortSignal });
                }, { abortSignal: abortSignal, timeoutInMs: timeoutInMs });
            }
            if (!this.isOpen()) {
                const rxOpt = {
                    source: {
                        address: this.endpoint,
                    },
                    name: this.replyTo,
                    onSessionError: (context) => {
                        const id = context.connection.options.id;
                        const ehError = translate(context.session.error);
                        logger.verbose("[%s] An error occurred on the session for request/response links " + "for $cbs: %O", id, ehError);
                    },
                };
                const srOpt = { target: { address: this.endpoint } };
                logger.verbose("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);
                this._cbsSenderReceiverLink = await RequestResponseLink.create(this.connection, srOpt, rxOpt, { abortSignal });
                this._cbsSenderReceiverLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                    const id = context.connection.options.id;
                    const ehError = translate(context.sender.error);
                    logger.verbose("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
                });
                this._cbsSenderReceiverLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                    const id = context.connection.options.id;
                    const ehError = translate(context.receiver.error);
                    logger.verbose("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
                });
                logger.verbose("[%s] Successfully created the cbs sender '%s' and receiver '%s' " +
                    "links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
            }
            else {
                logger.verbose("[%s] CBS session is already present. Reusing the cbs sender '%s' " +
                    "and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
            }
        }
        catch (err) {
            const translatedError = translate(err);
            logger.warning("[%s] An error occurred while establishing the cbs links: %s", this.connection.id, `${translatedError === null || translatedError === void 0 ? void 0 : translatedError.name}: ${translatedError === null || translatedError === void 0 ? void 0 : translatedError.message}`);
            logErrorStackTrace(translatedError);
            throw translatedError;
        }
    }
    /**
     * Negotiates the CBS claim with the EventHub/ServiceBus Service.
     * @param audience - The entity token audience for which the token is requested in one
     * of the following forms:
     *
     * - **ServiceBus**
     *    - **Sender**
     *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **Receiver**
     *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
     *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
     *
     * - **EventHubs**
     *     - **Sender**
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     *     - **Receiver**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     *     - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     * @param token - The token that needs to be sent in the put-token request.
     * @param tokenType - The type of token being used. For example, 'jwt' or 'servicebus.windows.net:sastoken'.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `negotiateClaim` invocation.
     * @returns A Promise that resolves when $cbs authentication is successful
     * and rejects when an error occurs during $cbs authentication.
     */
    async negotiateClaim(audience, token, tokenType, options = {}) {
        const { abortSignal, timeoutInMs } = options;
        try {
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                throw new abortController.AbortError(StandardAbortMessage);
            }
            if (!this._cbsSenderReceiverLink) {
                throw new Error("Attempted to negotiate a claim but the CBS link does not exist.");
            }
            const request = {
                body: token,
                message_id: rheaPromise.generate_uuid(),
                reply_to: this.replyTo,
                to: this.endpoint,
                application_properties: {
                    operation: Constants.operationPutToken,
                    name: audience,
                    type: tokenType,
                },
            };
            const responseMessage = await this._cbsSenderReceiverLink.sendRequest(request, {
                abortSignal,
                timeoutInMs,
                requestName: "negotiateClaim",
            });
            logger.verbose("[%s] The CBS response is: %O", this.connection.id, responseMessage);
            return this._fromRheaMessageResponse(responseMessage);
        }
        catch (err) {
            logger.warning("[%s] An error occurred while negotiating the cbs claim: %s", this.connection.id, `${err === null || err === void 0 ? void 0 : err.name}: ${err === null || err === void 0 ? void 0 : err.message}`);
            logErrorStackTrace(err);
            throw err;
        }
    }
    /**
     * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns
     */
    async close() {
        try {
            if (this.isOpen()) {
                const cbsLink = this._cbsSenderReceiverLink;
                this._cbsSenderReceiverLink = undefined;
                await cbsLink.close();
                logger.verbose("[%s] Successfully closed the cbs session.", this.connection.id);
            }
        }
        catch (err) {
            const msg = `An error occurred while closing the cbs link: ${err.stack || JSON.stringify(err)}.`;
            logger.verbose("[%s] %s", this.connection.id, msg);
            throw new Error(msg);
        }
    }
    /**
     * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * @returns void
     */
    remove() {
        try {
            if (this._cbsSenderReceiverLink) {
                const cbsLink = this._cbsSenderReceiverLink;
                this._cbsSenderReceiverLink = undefined;
                cbsLink.remove();
                logger.verbose("[%s] Successfully removed the cbs session.", this.connection.id);
            }
        }
        catch (err) {
            const msg = `An error occurred while removing the cbs link: ${err.stack || JSON.stringify(err)}.`;
            logger.verbose("[%s] %s", this.connection.id, msg);
            throw new Error(msg);
        }
    }
    /**
     * Indicates whether the cbs sender receiver link is open or closed.
     * @returns `true` open, `false` closed.
     */
    isOpen() {
        var _a;
        return Boolean((_a = this._cbsSenderReceiverLink) === null || _a === void 0 ? void 0 : _a.isOpen());
    }
    _fromRheaMessageResponse(msg) {
        const cbsResponse = {
            correlationId: msg.correlation_id,
            statusCode: msg.application_properties ? msg.application_properties["status-code"] : "",
            statusDescription: msg.application_properties
                ? msg.application_properties["status-description"]
                : "",
        };
        logger.verbose("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);
        return cbsResponse;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Describes the operations that can be performed on the message header.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.
const AmqpMessageHeader = {
    /**
     * Converts MessageHeader to RheaMessageHeader.
     *
     * @param props - Message header.
     * @returns RheaMessageHeader
     */
    toRheaMessageHeader(props) {
        const amqpHeader = {};
        if (props.deliveryCount != undefined) {
            amqpHeader.delivery_count = props.deliveryCount;
        }
        if (props.durable != undefined)
            amqpHeader.durable = props.durable;
        if (props.firstAcquirer != undefined) {
            amqpHeader.first_acquirer = props.firstAcquirer;
        }
        if (props.priority != undefined) {
            amqpHeader.priority = props.priority;
        }
        if (props.timeToLive != undefined) {
            amqpHeader.ttl = props.timeToLive;
        }
        logger.verbose("To RheaMessageHeader: %O", amqpHeader);
        return amqpHeader;
    },
    /**
     * Converts RheaMessageHeader to MessageHeader.
     *
     * @param props - Amqp Message Header
     * @returns MessageHeader.
     */
    fromRheaMessageHeader(props) {
        const msgHeader = {};
        if (props.delivery_count != undefined) {
            msgHeader.deliveryCount = props.delivery_count;
        }
        if (props.durable != undefined) {
            msgHeader.durable = props.durable;
        }
        if (props.first_acquirer != undefined) {
            msgHeader.firstAcquirer = props.first_acquirer;
        }
        if (props.priority != undefined) {
            msgHeader.priority = props.priority;
        }
        if (props.ttl != undefined) {
            msgHeader.timeToLive = props.ttl;
        }
        logger.verbose("From RheaMessageHeader: %O", msgHeader);
        return msgHeader;
    },
};

// Copyright (c) Microsoft Corporation.
/**
 * Describes the operations that can be performed on the amqp message properties.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.
const AmqpMessageProperties = {
    /**
     * Converts MessageProperties to RheaMessageProperties.
     * @param props - Message properties.
     * @returns RheaMessageProperties.
     */
    toRheaMessageProperties(props) {
        const amqpProperties = {};
        if (props.absoluteExpiryTime != undefined) {
            amqpProperties.absolute_expiry_time = new Date(props.absoluteExpiryTime);
        }
        if (props.contentEncoding != undefined) {
            amqpProperties.content_encoding = props.contentEncoding;
        }
        if (props.contentType != undefined) {
            amqpProperties.content_type = props.contentType;
        }
        if (props.correlationId != undefined) {
            amqpProperties.correlation_id = props.correlationId;
        }
        if (props.creationTime != undefined) {
            amqpProperties.creation_time = new Date(props.creationTime);
        }
        if (props.groupId != undefined) {
            amqpProperties.group_id = props.groupId;
        }
        if (props.groupSequence != undefined) {
            amqpProperties.group_sequence = props.groupSequence;
        }
        if (props.messageId != undefined) {
            amqpProperties.message_id = props.messageId;
        }
        if (props.replyTo != undefined) {
            amqpProperties.reply_to = props.replyTo;
        }
        if (props.replyToGroupId != undefined) {
            amqpProperties.reply_to_group_id = props.replyToGroupId;
        }
        if (props.subject != undefined) {
            amqpProperties.subject = props.subject;
        }
        if (props.to != undefined) {
            amqpProperties.to = props.to;
        }
        // if (props.userId != undefined) {
        //   amqpProperties.user_id = props.userId;
        // }
        logger.verbose("To RheaMessageProperties: %O", amqpProperties);
        return amqpProperties;
    },
    /**
     * Converts RheaMessageProperties to MessageProperties.
     * @param props - Amqp message properties.
     * @returns MessageProperties.
     */
    fromRheaMessageProperties(props) {
        const msgProperties = {};
        if (props.absolute_expiry_time != undefined) {
            msgProperties.absoluteExpiryTime = props.absolute_expiry_time.getTime();
        }
        if (props.content_encoding != undefined) {
            msgProperties.contentEncoding = props.content_encoding;
        }
        if (props.content_type != undefined) {
            msgProperties.contentType = props.content_type;
        }
        if (props.correlation_id != undefined) {
            msgProperties.correlationId = props.correlation_id;
        }
        if (props.creation_time != undefined) {
            msgProperties.creationTime = props.creation_time.getTime();
        }
        if (props.group_id != undefined) {
            msgProperties.groupId = props.group_id;
        }
        if (props.group_sequence != undefined) {
            msgProperties.groupSequence = props.group_sequence;
        }
        if (props.message_id != undefined) {
            msgProperties.messageId = props.message_id;
        }
        if (props.reply_to != undefined) {
            msgProperties.replyTo = props.reply_to;
        }
        if (props.reply_to_group_id != undefined) {
            msgProperties.replyToGroupId = props.reply_to_group_id;
        }
        if (props.subject != undefined) {
            msgProperties.subject = props.subject;
        }
        if (props.to != undefined) {
            msgProperties.to = props.to;
        }
        // if (props.user_id != undefined) {
        //   msgProperties.userId = props.user_id;
        // }
        logger.verbose("From RheaMessageProperties: %O", msgProperties);
        return msgProperties;
    },
};

// Copyright (c) Microsoft Corporation.
/**
 * Returns information about the platform this function is being run on.
 * @internal
 */
function getPlatformInfo() {
    return `(${os__namespace.arch()}-${os__namespace.type()}-${os__namespace.release()})`;
}
/**
 * Returns information about Node.js this function is being run on.
 * @internal
 */
function getFrameworkInfo() {
    return `Node/${process.version}`;
}

// Copyright (c) Microsoft Corporation.
const maxListenerLimit = 1000;
class CoreAmqpConnection extends rheaPromise.Connection {
    /**
     * Creates an amqp sender link. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create a sender link.
     * @returns Promise<Sender>.
     */
    async createSender(options) {
        const sender = await super.createSender(options);
        sender.setMaxListeners(maxListenerLimit);
        return sender;
    }
    /**
     * Creates an awaitable amqp sender. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create an awaitable sender link.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispositionMap` of inflight `send()` operation.
     *
     * @returns Promise<AwaitableSender>.
     */
    async createAwaitableSender(options) {
        const sender = await super.createAwaitableSender(options);
        sender.setMaxListeners(maxListenerLimit);
        return sender;
    }
    /**
     * Creates an amqp receiver link. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create a receiver link.
     * @returns Promise<Receiver>.
     */
    async createReceiver(options) {
        const receiver = await super.createReceiver(options);
        receiver.setMaxListeners(maxListenerLimit);
        return receiver;
    }
}
// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.
const ConnectionContextBase = {
    /**
     * Creates the base connection context.
     * @param parameters - Parameters to be provided to create
     * the base connection context.
     */
    create(parameters) {
        var _a, _b, _c;
        ConnectionConfig.validate(parameters.config, {
            isEntityPathRequired: parameters.isEntityPathRequired || false,
        });
        const userAgent = parameters.connectionProperties.userAgent;
        if (userAgent.length > Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
        }
        const connectionOptions = {
            transport: Constants.TLS,
            host: parameters.config.host,
            hostname: (_a = parameters.config.amqpHostname) !== null && _a !== void 0 ? _a : parameters.config.host,
            username: parameters.config.sharedAccessKeyName,
            port: (_b = parameters.config.port) !== null && _b !== void 0 ? _b : 5671,
            reconnect: false,
            properties: {
                product: parameters.connectionProperties.product,
                version: parameters.connectionProperties.version,
                "user-agent": userAgent,
                platform: getPlatformInfo(),
                framework: getFrameworkInfo(),
            },
            idle_time_out: Constants.defaultConnectionIdleTimeoutInMs,
            operationTimeoutInSeconds: parameters.operationTimeoutInMs
                ? parameters.operationTimeoutInMs / 1000
                : undefined,
        };
        if (parameters.config.webSocket ||
            (!isNode && typeof self !== "undefined" && self.WebSocket)) {
            const socket = parameters.config.webSocket || self.WebSocket;
            const host = parameters.config.host;
            const endpoint = parameters.config.webSocketEndpointPath || "";
            const socketOptions = parameters.config.webSocketConstructorOptions || {};
            const port = (_c = parameters.config.port) !== null && _c !== void 0 ? _c : 443;
            connectionOptions.webSocketOptions = {
                webSocket: socket,
                url: `wss://${host}:${port}/${endpoint}`,
                protocol: ["AMQPWSB10"],
                options: socketOptions,
            };
        }
        const connection = new CoreAmqpConnection(connectionOptions);
        const connectionLock = `${Constants.establishConnection}-${rheaPromise.generate_uuid()}`;
        const connectionContextBase = {
            wasConnectionCloseCalled: false,
            connectionLock: connectionLock,
            negotiateClaimLock: `${Constants.negotiateClaim}-${rheaPromise.generate_uuid()}`,
            connection: connection,
            connectionId: connection.id,
            cbsSession: new CbsClient(connection, connectionLock),
            config: parameters.config,
            refreshConnection() {
                const newConnection = new CoreAmqpConnection(connectionOptions);
                const newConnectionLock = `${Constants.establishConnection}-${rheaPromise.generate_uuid()}`;
                this.wasConnectionCloseCalled = false;
                this.connectionLock = newConnectionLock;
                this.negotiateClaimLock = `${Constants.negotiateClaim} - ${rheaPromise.generate_uuid()}`;
                this.connection = newConnection;
                this.connectionId = newConnection.id;
                this.cbsSession = new CbsClient(newConnection, newConnectionLock);
            },
        };
        return connectionContextBase;
    },
};

// Copyright (c) Microsoft Corporation.
/**
 * Describes the operations that can be performed on(or to get) the AmqpAnnotatedMessage.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.
const AmqpAnnotatedMessage = {
    /**
     * Takes RheaMessage(`Message` type from "rhea") and returns it in the AmqpAnnotatedMessage format.
     */
    fromRheaMessage(msg) {
        return {
            header: AmqpMessageHeader.fromRheaMessageHeader(msg),
            footer: msg.footer,
            messageAnnotations: msg.message_annotations,
            deliveryAnnotations: msg.delivery_annotations,
            applicationProperties: msg.application_properties,
            properties: AmqpMessageProperties.fromRheaMessageProperties(msg),
            body: msg.body,
        };
    },
    /**
     * Takes AmqpAnnotatedMessage and returns it in the RheaMessage(`Message` type from "rhea") format.
     */
    toRheaMessage(msg) {
        const message = Object.assign(Object.assign(Object.assign({}, AmqpMessageProperties.toRheaMessageProperties(msg.properties || {})), AmqpMessageHeader.toRheaMessageHeader(msg.header || {})), { body: msg.body, message_annotations: msg.messageAnnotations, delivery_annotations: msg.deliveryAnnotations, application_properties: msg.applicationProperties, footer: msg.footer });
        return message;
    },
};

// Copyright (c) Microsoft Corporation.
/**
 * Creates a token provider from the provided shared access data.
 * @param data - The sharedAccessKeyName/sharedAccessKey pair or the sharedAccessSignature.
 * @hidden
 */
function createSasTokenProvider(data) {
    if (coreAuth.isNamedKeyCredential(data) || coreAuth.isSASCredential(data)) {
        return new SasTokenProviderImpl(data);
    }
    else if (isObjectWithProperties(data, ["sharedAccessKeyName", "sharedAccessKey"])) {
        return new SasTokenProviderImpl({ name: data.sharedAccessKeyName, key: data.sharedAccessKey });
    }
    else {
        return new SasTokenProviderImpl({ signature: data.sharedAccessSignature });
    }
}
/**
 * A TokenProvider that generates a Sas token:
 * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`
 *
 * @internal
 */
class SasTokenProviderImpl {
    /**
     * Initializes a new instance of SasTokenProvider
     * @param credential - The source `NamedKeyCredential` or `SASCredential`.
     */
    constructor(credential) {
        this._credential = credential;
    }
    /**
     * Property used to distinguish TokenProvider from TokenCredential.
     */
    get isSasTokenProvider() {
        return true;
    }
    /**
     * Gets the sas token for the specified audience
     * @param audience - The audience for which the token is desired.
     */
    getToken(audience) {
        if (coreAuth.isNamedKeyCredential(this._credential)) {
            return createToken(this._credential.name, this._credential.key, Math.floor(Date.now() / 1000) + 3600, audience);
        }
        else {
            return {
                token: this._credential.signature,
                expiresOnTimestamp: 0,
            };
        }
    }
}
/**
 * Creates the sas token based on the provided information.
 * @param keyName - The shared access key name.
 * @param key - The shared access key.
 * @param expiry - The time period in unix time after which the token will expire.
 * @param audience - The audience for which the token is desired.
 * @internal
 */
function createToken(keyName, key, expiry, audience) {
    audience = encodeURIComponent(audience);
    keyName = encodeURIComponent(keyName);
    const stringToSign = audience + "\n" + expiry;
    const shaObj = new jssha__default["default"]("SHA-256", "TEXT");
    shaObj.setHMACKey(key, "TEXT");
    shaObj.update(stringToSign);
    const sig = encodeURIComponent(shaObj.getHMAC("B64"));
    return {
        token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
        expiresOnTimestamp: expiry,
    };
}

exports.AmqpAnnotatedMessage = AmqpAnnotatedMessage;
exports.AmqpMessageHeader = AmqpMessageHeader;
exports.AmqpMessageProperties = AmqpMessageProperties;
exports.CbsClient = CbsClient;
exports.ConnectionConfig = ConnectionConfig;
exports.ConnectionContextBase = ConnectionContextBase;
exports.Constants = Constants;
exports.MessagingError = MessagingError;
exports.RequestResponseLink = RequestResponseLink;
exports.StandardAbortMessage = StandardAbortMessage;
exports.createSasTokenProvider = createSasTokenProvider;
exports.defaultCancellableLock = defaultCancellableLock;
exports.delay = delay;
exports.isMessagingError = isMessagingError;
exports.isSasTokenProvider = isSasTokenProvider;
exports.isSystemError = isSystemError;
exports.logger = logger;
exports.parseConnectionString = parseConnectionString;
exports.retry = retry;
exports.retryableErrors = retryableErrors;
exports.translate = translate;
//# sourceMappingURL=index.js.map
