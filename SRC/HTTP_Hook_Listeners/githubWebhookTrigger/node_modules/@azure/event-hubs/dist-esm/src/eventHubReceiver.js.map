{"version":3,"file":"eventHubReceiver.js","sourceRoot":"","sources":["../../src/eventHubReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  Constants,\n  MessagingError,\n  RetryConfig,\n  RetryOperationType,\n  StandardAbortMessage,\n  delay,\n  retry,\n  translate,\n} from \"@azure/core-amqp\";\nimport {\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverOptions as RheaReceiverOptions,\n  types,\n} from \"rhea-promise\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\n\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the message handler signature.\n * @internal\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n * @internal\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n * @internal\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @internal\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * The RHEA AMQP-based receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onError?: OnError;\n  /**\n   * The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * The sequence number of the most recently received AMQP message.\n   */\n  private _checkpoint: number = -1;\n  /**\n   * A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * Indicates if messages are being received from this receiver.\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * Indicated if messages are being received in streaming mode.\n   */\n  private _isStreaming: boolean = false;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Indicates if the receiver has been closed.\n   */\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this.runtimeInfo;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @param context -        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup -  The consumer group from which the receiver should receive events from.\n   * @param partitionId -    The Partition ID from which to receive.\n   * @param eventPosition -  The position in the stream from where to start receiving events.\n   * @param options -      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup),\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n    const data: EventDataInternal = fromRheaMessage(\n      context.message,\n      !!this.options.skipParsingBodyAsJson\n    );\n    const rawMessage = data.getRawAmqpMessage();\n    const receivedEventData: ReceivedEventData = {\n      body: data.body,\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties,\n      getRawAmqpMessage() {\n        return rawMessage;\n      },\n    };\n    if (data.correlationId != null) {\n      receivedEventData.correlationId = data.correlationId;\n    }\n    if (data.contentType != null) {\n      receivedEventData.contentType = data.contentType;\n    }\n    if (data.messageId != null) {\n      receivedEventData.messageId = data.messageId;\n    }\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(desc);\n    if (this._onError) {\n      const error = new AbortError(StandardAbortMessage);\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   */\n  async close(): Promise<void> {\n    try {\n      this.clearHandlers();\n\n      if (!this._receiver) {\n        return;\n      }\n\n      const receiverLink = this._receiver;\n      this._deleteFromCache();\n      await this._closeLink(receiverLink);\n    } catch (err: any) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing receiver ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize({\n              abortSignal,\n              timeoutInMs: getRetryAttemptTimeoutInMs(this.options.retryOptions),\n            });\n          } catch (err: any) {\n            if (this._onError === onError) {\n              onError(err);\n            }\n            return;\n          }\n        } else {\n          logger.verbose(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n        return;\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  async initialize({\n    abortSignal,\n    timeoutInMs,\n  }: {\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim({ setTokenRenewal: false, abortSignal, timeoutInMs });\n\n        const receiverOptions: CreateReceiverOptions = {\n          onClose: (context: EventContext) => this._onAmqpClose(context),\n          onError: (context: EventContext) => this._onAmqpError(context),\n          onMessage: (context: EventContext) => this._onAmqpMessage(context),\n          onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n          onSessionError: (context: EventContext) => this._onAmqpSessionError(context),\n        };\n        if (this.checkpoint > -1) {\n          receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n        }\n        const options = this._createReceiverOptions(receiverOptions);\n\n        logger.verbose(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver({ ...options, abortSignal });\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err: any) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occured while creating the receiver '%s': %s\",\n        this._context.connectionId,\n        this.name,\n        `${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address,\n      },\n      credit_window: 0,\n      onMessage: options.onMessage,\n      onError: options.onError,\n      onClose: options.onClose,\n      onSessionError: options.onSessionError,\n      onSessionClose: options.onSessionClose,\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel),\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004),\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds - The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise((resolve, reject) => {\n        // if this consumer was closed,\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (this._isClosed || this._context.wasConnectionCloseCalled) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const name = this.name;\n          const address = this.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            reject(new AbortError(StandardAbortMessage));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          this.clearHandlers();\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            // restore events to the front of the internal queue.\n            while (receivedEvents.length) {\n              this._internalQueue.unshift(receivedEvents.pop()!);\n            }\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(msg, this._context.connectionId, maxWaitTimeInSeconds, this.name);\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this.options.retryOptions || {};\n\n    const config: RetryConfig<ReceivedEventData[]> = Object.defineProperties(\n      {\n        operation: retrieveEvents,\n        operationType: RetryOperationType.receiveMessage,\n        abortSignal: abortSignal,\n        retryOptions: retryOptions,\n      },\n      {\n        connectionId: {\n          enumerable: true,\n          get: () => {\n            return this._context.connectionId;\n          },\n        },\n        connectionHost: {\n          enumerable: true,\n          get: () => {\n            return this._context.config.host;\n          },\n        },\n      }\n    ) as RetryConfig<ReceivedEventData[]>;\n    return retry<ReceivedEventData[]>(config);\n  }\n}\n"]}