{"version":3,"file":"blobCheckpointStore.js","sourceRoot":"","sources":["../../src/blobCheckpointStore.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CheckpointStore, PartitionOwnership, Checkpoint } from \"@azure/event-hubs\";\nimport { ContainerClient, Metadata, RestError, BlobSetMetadataResponse } from \"@azure/storage-blob\";\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\n\n/**\n * An implementation of CheckpointStore that uses Azure Blob Storage to persist checkpoint data.\n * @class\n */\nexport class BlobCheckpointStore implements CheckpointStore {\n  private _containerClient: ContainerClient;\n\n  constructor(containerClient: ContainerClient) {\n    this._containerClient = containerClient;\n  }\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. May return empty\n   * results if there are is no existing ownership information.\n   * Partition Ownership contains the information on which `EventHubConsumerClient` subscribe call is currently processing the partition.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   * @return Partition ownership details of all the partitions that have had an owner.\n   */\n  async listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const partitionOwnershipArray: PartitionOwnership[] = [];\n\n    const blobPrefix = BlobCheckpointStore.getBlobPrefix({\n      type: \"ownership\",\n      fullyQualifiedNamespace,\n      eventHubName,\n      consumerGroup: consumerGroup\n    });\n\n    try {\n      const blobs = this._containerClient.listBlobsFlat({\n        includeMetadata: true,\n        prefix: blobPrefix\n      });\n\n      for await (const blob of blobs) {\n        const blobPath = blob.name.split(\"/\");\n        const blobName = blobPath[blobPath.length - 1];\n\n        const ownershipMetadata = blob.metadata as OwnershipMetadata;\n\n        if (ownershipMetadata.ownerid == null) {\n          throw new Error(`Missing ownerid in metadata for blob ${blob.name}`);\n        }\n\n        const partitionOwnership: PartitionOwnership = {\n          fullyQualifiedNamespace,\n          eventHubName,\n          consumerGroup: consumerGroup,\n          ownerId: ownershipMetadata.ownerid,\n          partitionId: blobName,\n          lastModifiedTimeInMs:\n            blob.properties.lastModified && blob.properties.lastModified.getTime(),\n          etag: blob.properties.etag\n        };\n        partitionOwnershipArray.push(partitionOwnership);\n      }\n      return partitionOwnershipArray;\n    } catch (err) {\n      logger.warning(`Error occurred while fetching the list of blobs`, err.message);\n      logErrorStackTrace(err);\n      throw new Error(`Error occurred while fetching the list of blobs. \\n${err}`);\n    }\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were\n   * successfully claimed.\n   *\n   * @param partitionOwnership The list of partition ownership this instance is claiming to own.\n   * @return A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    let partitionOwnershipArray: PartitionOwnership[] = [];\n    for (const ownership of partitionOwnership) {\n      const blobName = BlobCheckpointStore.getBlobPrefix({ type: \"ownership\", ...ownership });\n      try {\n        let updatedBlobResponse = await this._setBlobMetadata(\n          blobName,\n          {\n            ownerid: ownership.ownerId\n          },\n          ownership.etag\n        );\n\n        if (updatedBlobResponse.lastModified) {\n          ownership.lastModifiedTimeInMs = updatedBlobResponse.lastModified.getTime();\n        }\n\n        ownership.etag = updatedBlobResponse.etag;\n        partitionOwnershipArray.push(ownership);\n        logger.info(\n          `[${ownership.ownerId}] Claimed ownership successfully for partition: ${ownership.partitionId}`,\n          `LastModifiedTime: ${ownership.lastModifiedTimeInMs}, ETag: ${ownership.etag}`\n        );\n      } catch (err) {\n        const restError = err as RestError;\n\n        if (restError.statusCode === 412) {\n          // etag failures (precondition not met) aren't fatal errors. They happen\n          // as multiple consumers attempt to claim the same partition (first one wins)\n          // and losers get this error.\n          logger.verbose(\n            `[${ownership.ownerId}] Did not claim partition ${ownership.partitionId}. Another processor has already claimed it.`\n          );\n          continue;\n        }\n\n        logger.warning(\n          `Error occurred while claiming ownership for partition: ${ownership.partitionId}`,\n          err.message\n        );\n        logErrorStackTrace(err);\n\n        throw err;\n      }\n    }\n    return partitionOwnershipArray;\n  }\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName The event hub name.\n   * @param consumerGroup The consumer group name.\n   */\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const blobPrefix = BlobCheckpointStore.getBlobPrefix({\n      type: \"checkpoint\",\n      fullyQualifiedNamespace,\n      eventHubName,\n      consumerGroup\n    });\n\n    const blobs = this._containerClient.listBlobsFlat({\n      includeMetadata: true,\n      prefix: blobPrefix\n    });\n\n    const checkpoints: Checkpoint[] = [];\n\n    for await (const blob of blobs) {\n      const blobPath = blob.name.split(\"/\");\n      const blobName = blobPath[blobPath.length - 1];\n\n      const checkpointMetadata = blob.metadata as CheckpointMetadata;\n\n      const offset = parseIntOrThrow(blob.name, \"offset\", checkpointMetadata.offset);\n      const sequenceNumber = parseIntOrThrow(\n        blob.name,\n        \"sequencenumber\",\n        checkpointMetadata.sequencenumber\n      );\n\n      checkpoints.push({\n        consumerGroup,\n        eventHubName,\n        fullyQualifiedNamespace,\n        partitionId: blobName,\n        offset,\n        sequenceNumber\n      });\n    }\n\n    return checkpoints;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint The checkpoint.\n   * @return The new etag on successful update.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    const blobName = BlobCheckpointStore.getBlobPrefix({ type: \"checkpoint\", ...checkpoint });\n    try {\n      const metadataResponse = await this._setBlobMetadata(\n        blobName,\n        {\n          sequencenumber: checkpoint.sequenceNumber.toString(),\n          offset: checkpoint.offset.toString()\n        },\n        undefined\n      );\n\n      logger.verbose(\n        `Updated checkpoint successfully for partition: ${checkpoint.partitionId}`,\n        `LastModifiedTime: ${metadataResponse.lastModified!.toISOString()}, ETag: ${\n          metadataResponse.etag\n        }`\n      );\n      return;\n    } catch (err) {\n      logger.warning(\n        `Error occurred while upating the checkpoint for partition: ${checkpoint.partitionId}.`,\n        err.message\n      );\n      logErrorStackTrace(err);\n      throw new Error(\n        `Error occurred while upating the checkpoint for partition: ${checkpoint.partitionId}, ${err}`\n      );\n    }\n  }\n\n  private static getBlobPrefix(params: {\n    type: \"ownership\" | \"checkpoint\";\n    fullyQualifiedNamespace: string;\n    eventHubName: string;\n    consumerGroup: string;\n    partitionId?: string;\n  }): string {\n    // none of these are case-sensitive in eventhubs so we need to make sure we don't accidentally allow\n    // the user to create a case-sensitive blob for their state!\n    const consumerGroupName = params.consumerGroup.toLowerCase();\n    const eventHubName = params.eventHubName.toLowerCase();\n    const fullyQualifiedNamespace = params.fullyQualifiedNamespace.toLowerCase();\n\n    if (params.partitionId) {\n      return `${fullyQualifiedNamespace}/${eventHubName}/${consumerGroupName}/${params.type}/${params.partitionId}`;\n    } else {\n      return `${fullyQualifiedNamespace}/${eventHubName}/${consumerGroupName}/${params.type}/`;\n    }\n  }\n\n  private async _setBlobMetadata(\n    blobName: string,\n    metadata: OwnershipMetadata | CheckpointMetadata,\n    etag: string | undefined\n  ): Promise<BlobSetMetadataResponse> {\n    const blockBlobClient = this._containerClient.getBlobClient(blobName).getBlockBlobClient();\n\n    // When we have an etag, we know the blob existed.\n    // If we encounter an error we should fail.\n    if (etag) {\n      return blockBlobClient.setMetadata(metadata as Metadata, {\n        conditions: {\n          ifMatch: etag\n        }\n      });\n    } else {\n      try {\n        // Attempt to set metadata, and fallback to upload if the blob doesn't already exist.\n        // This avoids poor performance in storage accounts with soft-delete or blob versioning enabled.\n        // https://github.com/Azure/azure-sdk-for-js/issues/10132\n        return await blockBlobClient.setMetadata(metadata as Metadata);\n      } catch (err) {\n        // Check if the error is `BlobNotFound` and fallback to `upload` if it is.\n        if (err?.name !== \"RestError\") {\n          throw err;\n        }\n        const errorDetails = (err as RestError).details as { [field: string]: string } | undefined;\n        const errorCode = errorDetails?.errorCode;\n        if (!errorCode || errorCode !== \"BlobNotFound\") {\n          throw err;\n        }\n\n        return blockBlobClient.upload(\"\", 0, {\n          metadata: metadata as Metadata\n        });\n      }\n    }\n  }\n}\n\ntype OwnershipMetadata = {\n  [k in \"ownerid\"]: string | undefined;\n};\n\ntype CheckpointMetadata = {\n  [k in \"sequencenumber\" | \"offset\"]: string | undefined;\n};\n\n/**\n * @ignore\n * @internal\n */\nexport function parseIntOrThrow(\n  blobName: string,\n  fieldName: string,\n  numStr: string | undefined\n): number {\n  if (numStr == null) {\n    throw new Error(`Missing metadata property '${fieldName}' on blob '${blobName}'`);\n  }\n\n  const num = parseInt(numStr, 10);\n\n  if (isNaN(num)) {\n    throw new Error(\n      `Failed to parse metadata property '${fieldName}' on blob '${blobName}' as a number`\n    );\n  }\n\n  return num;\n}\n"]}