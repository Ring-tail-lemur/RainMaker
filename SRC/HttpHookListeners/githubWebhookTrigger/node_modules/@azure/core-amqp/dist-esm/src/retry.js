// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */
import { translate } from "./errors";
import { Constants } from "./util/constants";
import { checkNetworkConnection } from "./util/checkNetworkConnection";
import { delay } from "./util/utils";
import { logger } from "./log";
/**
 * Determines whether the object is a Delivery object.
 * @internal
 */
function isDelivery(obj) {
    let result = false;
    if (obj &&
        typeof obj.id === "number" &&
        typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" &&
        typeof obj.format === "number") {
        result = true;
    }
    return result;
}
/**
 * Describes the Retry Mode type
 */
export var RetryMode;
(function (RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})(RetryMode || (RetryMode = {}));
/**
 * Describes the retry operation type.
 */
export var RetryOperationType;
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["receiveMessage"] = "receiveMessage";
    RetryOperationType["session"] = "session";
    RetryOperationType["messageSettlement"] = "settlement";
})(RetryOperationType || (RetryOperationType = {}));
/**
 * Validates the retry config.
 * @internal
 */
function validateRetryConfig(config) {
    if (!config.operation) {
        throw new TypeError("Missing 'operation' in retry configuration");
    }
    if (!config.connectionId) {
        throw new TypeError("Missing 'connectionId' in retry configuration");
    }
    if (!config.operationType) {
        throw new TypeError("Missing 'operationType' in retry configuration");
    }
}
/**
 * Calculates delay between retries, in milliseconds.
 * @internal
 */
function calculateDelay(attemptCount, retryDelayInMs, maxRetryDelayInMs, mode) {
    if (mode === RetryMode.Exponential) {
        const boundedRandDelta = retryDelayInMs * 0.8 +
            Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));
        const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);
        return Math.min(incrementDelta, maxRetryDelayInMs);
    }
    return retryDelayInMs;
}
/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param config - Parameters to configure retry operation
 *
 * @returns Promise<T>.
 */
export async function retry(config) {
    validateRetryConfig(config);
    if (!config.retryOptions) {
        config.retryOptions = {};
    }
    if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) {
        config.retryOptions.maxRetries = Constants.defaultMaxRetries;
    }
    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
        config.retryOptions.retryDelayInMs = Constants.defaultDelayBetweenOperationRetriesInMs;
    }
    if (config.retryOptions.maxRetryDelayInMs == undefined ||
        config.retryOptions.maxRetryDelayInMs < 0) {
        config.retryOptions.maxRetryDelayInMs = Constants.defaultMaxDelayForExponentialRetryInMs;
    }
    if (config.retryOptions.mode == undefined) {
        config.retryOptions.mode = RetryMode.Fixed;
    }
    let lastError;
    let result;
    let success = false;
    const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;
    for (let i = 1; i <= totalNumberOfAttempts; i++) {
        logger.verbose("[%s] Attempt number for '%s': %d.", config.connectionId, config.operationType, i);
        try {
            result = await config.operation();
            success = true;
            logger.verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);
            if (result && !isDelivery(result)) {
                logger.verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
            }
            break;
        }
        catch (_err) {
            let err = _err;
            if (!err.translated) {
                err = translate(err);
            }
            if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                const isConnected = await checkNetworkConnection(config.connectionHost);
                if (!isConnected) {
                    err.name = "ConnectionLostError";
                    err.retryable = true;
                }
            }
            lastError = err;
            logger.verbose("[%s] Error occurred for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);
            if (lastError && lastError.retryable && totalNumberOfAttempts > i) {
                const targetDelayInMs = calculateDelay(i, config.retryOptions.retryDelayInMs, config.retryOptions.maxRetryDelayInMs, config.retryOptions.mode);
                logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);
                await delay(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
                continue;
            }
            else {
                break;
            }
        }
    }
    if (success) {
        return result;
    }
    else {
        throw lastError;
    }
}
//# sourceMappingURL=retry.js.map